{
open Lexing
open Dyp

let set_newline dyplexbuf =
  let l = Dyp.std_lexbuf dyplexbuf in
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
let dypgen_choose_token = `all
}

%start main

%relation atom<seq

%layout [ ' ' '\r' '\t' ]

%lexer

let utf8_char =
    ['\033'-'\091''\093'-'\127']
  | ['\194'-'\223']['\129'-'\191']
  | ['\224'-'\238']['\129'-'\191']['\129'-'\191']
  | '\239'['\129'-'\159']['\129'-'\191']
  | ['\240'-'\243']['\129'-'\191']['\129'-'\191']['\129'-'\191']
  | '\244'['\129'-'\143']['\129'-'\191']['\129'-'\191']

let macro = ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']

main lexer =
  utf8_char+ -> WORD { Dyp.lexeme lexbuf }
  '\n' -> NEWLINE { set_newline lexbuf }
  '\\''\\' -> CHAR { "\\" }
  '\\' -> SPECIAL


%parser

paragraph:
    WORD<w> { w }
  | paragraph<p> NEWLINE? WORD<w> { p ^ " " ^ w }

preambule:
  [NEWLINE]*
	{ None }

parskip:
  | NEWLINE [NEWLINE]+

text:
    paragraph<p>
    { [p] }
  | text<t> parskip paragraph<p>
    { p :: t }

main:
  | preambule<p> text<t> [NEWLINE]* eof
    { p, List.rev t }
  
