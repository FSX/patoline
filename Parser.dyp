
{
open Lexing
open Dyp

exception Syntax_Error of Lexing.position * string

let set_newline dyplexbuf =
  let l = Dyp.std_lexbuf dyplexbuf in
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
(* let dypgen_choose_token = `all *)

let dyp_merge = keep_one

type doc =
     Paragraph of string
   | Caml of int * int
   | Struct of (string * doc list)

let comment_stack = Stack.create ()


let push_comment () = Stack.push `Comment comment_stack
let push_caml () = 
  try 
    match Stack.top comment_stack with
       `Comment -> ()
     | _ -> Stack.push `Caml comment_stack
  with
    Stack.Empty -> Stack.push `Caml comment_stack

let pop_comment (lexbuf:('a Dyp.dyplexbuf)) = 
  try
    match Stack.pop comment_stack with
      `Comment -> Stack.is_empty comment_stack
    | `Caml -> 
	raise (Syntax_Error (Dyp.lexeme_start_p lexbuf,
		"Coment ended as goal."))
  with
    Stack.Empty -> 
	raise (Syntax_Error (Dyp.lexeme_start_p lexbuf,
		"Illegal closing comment"))

let pop_caml (lexbuf:('a Dyp.dyplexbuf)) = 
  try
    match Stack.top comment_stack with
      `Caml -> ignore (Stack.pop comment_stack); Stack.is_empty comment_stack
    | `Comment -> false
  with
    Stack.Empty -> 
	raise (Syntax_Error (Dyp.lexeme_start_p lexbuf,
		"Illegal closing goal"))
}

%start main

%relation atom<seq

%layout [ ' ' '\r' '\t' ]

%lexer

let utf8_char =
    ['\033'-'\127']
  | ['\194'-'\223']['\129'-'\191']
  | ['\224'-'\238']['\129'-'\191']['\129'-'\191']
  | '\239'['\129'-'\159']['\129'-'\191']
  | ['\240'-'\243']['\129'-'\191']['\129'-'\191']['\129'-'\191']
  | '\244'['\129'-'\143']['\129'-'\191']['\129'-'\191']

let macro = ['A'-'Z''a'-'z''_']['A'-'Z''a'-'z''0'-'9''_']

rule comment = parse
    '*' ')' { if pop_comment lexbuf then () else comment lexbuf }
  | '}' '}' { if pop_caml lexbuf then () else comment lexbuf } 
  | '(' '*' { push_comment (); comment lexbuf } 
  | '{' '{' { push_caml (); comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unterminated comment")) }
  | '\n' { set_newline lexbuf; comment lexbuf }
  | _ { comment lexbuf }

main lexer =
  '\n' -> NEWLINE { set_newline lexbuf }
  '=''='+ -> SECT { Dyp.lexeme lexbuf }
  '(' '*' -> { push_comment (); comment lexbuf }
  '{' '{' -> CAML { let l = Dyp.std_lexbuf lexbuf in 
		    let start = l.lex_start_p.pos_cnum + 2 in 
		    push_caml (); comment lexbuf;
		    start, l.lex_start_p.pos_cnum
		  }
  utf8_char+ -> WORD { Dyp.lexeme lexbuf }

%parser

paragraph:
    WORD<w> { w }
  | paragraph<p> NEWLINE? WORD<w> { p ^ " " ^ w }

preambule:
  [NEWLINE]*
	{ None }
| - SECT<st> [NEWLINE]*
  paragraph<title> [NEWLINE]*
  [ parskip paragraph<author> [NEWLINE]* 
    [parskip paragraph]?<institute> [NEWLINE]* {author, institute} ]?<at> 
  - SECT<en> [NEWLINE]*    
  { if String.length $1 < 10 or String.length en < 10 then raise Giveup;
    Some(title,at) }

parskip:
  | NEWLINE [NEWLINE]+

ptext:
  /* empty */
    {[]}
  | parskip text<t>
    { t }

textp:
    { [] }
  | text<t> parskip
    { t }

textn:
    { [] }
  | text<t> [NEWLINE]*
    { t }

text:
  | textp<t> paragraph<p>
    { Paragraph p :: t }
  | textn<t> - "=>" NEWLINE? paragraph<title> ptext<content> [NEWLINE]* "=<"
    { Struct(title, List.rev content) :: t }
  | textn<t> CAML<s,e> [NEWLINE]*
    { Caml(s,e) :: t }

main:
  | preambule<p> text<t> [NEWLINE]* eof
    { p, List.rev t }
  
