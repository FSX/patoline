{
open Lexing
open Dyp

exception Syntax_Error of Lexing.position * string

let set_newline dyplexbuf =
  let l = Dyp.std_lexbuf dyplexbuf in
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
(* let dypgen_choose_token = `all *)

let dyp_merge = keep_one

type math =
     Var of string
   | Symbol of string
   | Fun of string
   | Num of string   
   | Prefix of int * string * bool * math
   | Postfix of int * math * bool * string
   | Binary of int * math * bool * string * bool * math
   | Indices of indices * math
   | Apply of math * math
   | Delim of string * math * string  

and indices = { up_right : math option;
    down_right : math option; 
    up_left : math option;
    down_left : math option }

type structType = Absolute of int | Relative of doc list

and doc =
     Paragraph of content list
   | Verbatim of (string option * string list)
   | Caml of int * int
   | Struct of content list * bool * structType
   | Macro of [ `Single | `Module | `Begin | `End ] * string * doc list
   | Math of math  
   | Ignore

and content =
     TC of string
   | FC of math
   | MC of [ `Single | `Module | `Begin | `End ] * string * doc list
   | GC

let comment_depth = ref 0 let push_comment () = incr comment_depth
let caml_depth = ref 0 let push_caml () = incr caml_depth
let pop_comment () = decr comment_depth; !comment_depth = 0
let pop_caml () = decr caml_depth; !caml_depth = 0
let pop_caml' lexbuf =
     decr caml_depth; 
     if !caml_depth = 0	then
      raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Splitted end of caml code"))

let concat words =
    let non_word  = [  "(" ; ")" ; "[" ; "]" ; "{" ; "}" ; "$"; "\""; "^"; "_"; "-"  ] in
    let rec fn acc last = function
      [] -> acc
    | (w::l) ->
       let last' = List.mem w non_word in
       let acc = if last' || last then w ^ acc else w ^" "^acc in
       fn acc last' l
    in fn "" true (List.rev words) 

let has_space dyp =
    let next = dyp.next_lexeme () in
    match next with
      [] -> false
    | s::_ when s<>"" && (s.[0] = ' ' or s.[0] = '\t') -> true
    | [_] -> false
    | _ -> true 

let layout_info dyp a b =
    let a = dyp.rhs_end_pos a in
    let b = dyp.rhs_start_pos b in
    let cdiff = b.pos_cnum - a.pos_cnum in
    let ldiff = b.pos_lnum - a.pos_lnum in
    cdiff, ldiff

let layout_newline dyp a b =
    snd (layout_info dyp a b) > 0

let layout_empty dyp a b =
    fst (layout_info dyp a b) = 0

module Str = struct
  type t = string
  let compare = compare
end

module StrSet = Set.Make(Str)

type local_data = { infixes : StrSet.t;  other_symbols : StrSet.t; verbose : bool }

let local_data = { infixes = StrSet.empty; other_symbols = StrSet.empty; verbose = false }

let add_symbol_rule local_data rule_name rule_constr symbols symbol_value =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched _ ] -> rule_constr symbol_value, []
    | _ -> assert false
  in
  let elt = if local_data.verbose then [Ignore] else
    [Ignore; Paragraph
      [FC (Binary(0, Symbol symbol_value, false, "⇐", false,
      List.fold_right (fun s acc -> 
        let elt = Symbol (String.escaped s) in
        if acc = Var "" then elt else
	Binary(0, elt, true, ",", false, acc)) symbols (Var "")))]] 
  in
  elt, [Add_rules[rule, action]; Local_data local_data]

let gram_ext = if Dynlink.is_native then ".tgx" else ".tgo"
}

%start main
%start math 
%start paragraph

%relation atom < fun < ind < prod < sum < rel < neg < conj < impl < punc
%relation endany < endatom
%relation endany < endpar

%layout [ ' ' '\t' ]

%lexer

let utf8_char =
    ['\033' '\035' '\037'-'\039' '\042'-'\044' '\046'-'\060' '\062'-'\090' '\096'-'\122' '\124''\126''\127']
  | ['\194'-'\223']['\129'-'\191']
  | ['\224'-'\238']['\129'-'\191']['\129'-'\191']
  | '\239'['\129'-'\159']['\129'-'\191']
  | ['\240'-'\243']['\129'-'\191']['\129'-'\191']['\129'-'\191']
  | '\244'['\129'-'\143']['\129'-'\191']['\129'-'\191']

let string = '"' ([^'"'] | "\\\"")* '"'

let verbatim_line = (''' ''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    (''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    ([^'\n' '\r' '''] [^'\n''\r']*) | 
		    (''' '''?)

let lident = ['a'-'z'] ['a'-'z''A'-'Z''0'-'9']*

let uident = ['A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*

let word = utf8_char+ | '(' | ')' | '[' | ']' | '"' | "=" | '-'

let line = word (" "+ word)*

rule comment = parse
    '*' ')' {  if pop_comment () then () else comment lexbuf }
  | '(' '*' {  push_comment (); comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unterminated comment")) }
  | '\n' {  set_newline lexbuf; comment lexbuf }
  | string {  comment lexbuf }
  | _ {  comment lexbuf }

and caml = parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unexpected end of comment")) }
  | '}' '}' { pop_caml' lexbuf ; if pop_caml () then () else caml lexbuf } 
  | '}' { pop_caml' lexbuf; caml lexbuf } 
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; caml lexbuf } 
  | '{' { push_caml (); caml lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unterminated comment")) }
  | '\n' { set_newline lexbuf; caml lexbuf }
  | string { caml lexbuf }
  | _ { caml lexbuf }

main lexer =
  '(' '*' -> { push_comment (); comment lexbuf }
  '{' '{' -> CAML { let l = Dyp.std_lexbuf lexbuf in 
		    let start = l.lex_start_p.pos_cnum + 2 in 
		    push_caml (); push_caml (); caml lexbuf;
		    start, l.lex_start_p.pos_cnum
		  }
  '\n' -> NEWL { set_newline lexbuf }
  '\\' "Begin" -> BEGIN
  '\\' "End" -> END
  '\\' lident
    -> PMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '\\' uident
    -> TMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  
%parser

newline:
  NEWL { () }

parelt:
    parmacro<m> { m, has_space dyp }
  | "$" math<m> "$" { FC m, has_space dyp }
  | word<w> { TC (w), has_space dyp }

nparagraph:
  | parelt<e,sp>   
    { [e], sp }
  | nparagraph<p,sp> [newline]? parelt<e,sp'> 
    { (e :: if sp && p <> [] then GC::p else p), sp' }

paragraph:
    nparagraph<p,_> { List.rev p }

eparagraph:
    { [] } | nparagraph<p,_> { List.rev p }

starttitle: ("=========="('='*))

title:
  starttitle 
    [newline]+ paragraph<title> [newline]*
    [newline newline paragraph<author> [newline]* 
    [newline newline paragraph]?<institute> [newline]* {author, institute} ]?<at> 
  starttitle 
  { (title,at) }

grammar_aux:
    { Some "texprimeDefault" }
  |  [newline]* - "\\Use_Grammar{" [^'}']*<name> "}"
    { Printf.fprintf stderr "Some\n"; Some name }
  |  [newline]* - "\\No_Grammar"
    { Printf.fprintf stderr "None\n"; None }

grammar: grammar_aux<g>
  @{ let action = match g with None -> [] |
        Some filename -> 
	  try 
	  let ic = open_in (filename ^ gram_ext) in
	  let local_data, grammar = input_value ic in
	  close_in ic;
	  Printf.fprintf stderr "Grammar Loaded.\n";
	  [ Local_data local_data; Parser grammar ] 
          with e -> Printf.fprintf stderr "No Grammar Loaded (%s).\n" (Printexc.to_string e); []
       in
      (), action }

args:
    /* empty */
    { [] }
  | args<a> newline? "{" eparagraph<p> [newline]* "}" 
    { Paragraph p::a }
  | args<a> newline? CAML<s,e>
    { Caml(s,e) :: a }

topmacro:
    BEGIN "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" args<a>
      { Macro(`Begin, name, List.rev a) }
  | END "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" args<a>
      { Macro(`End, name, List.rev a) }
  | TMACRO<name> args<a>
      { Macro(`Module, name, List.rev a) }

parmacro:
  | PMACRO<name> args<a>
      { MC(`Single, name, List.rev a) }

leftind:
  | math(<=atom)<m1> - "^^" - math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = Some m1; down_right = None; down_left = Some m2 } }
  | math(<=atom)<m1> - "__" - math(<=atom)<m2> - "^^" 
      { { up_right = None; up_left = Some m2; down_right = None; down_left = Some m1 } }
  | math(<=atom)<m1> - "^^"
      { { up_right = None; up_left = Some m1; down_right = None; down_left = None } }
  | math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = None; down_right = None; down_left = Some m2 } }

rightind:
    /* empty */
      { (fun i -> i) }
  | "^" - math(<=atom)<m1> - "_" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m1; down_right = Some m2 } }
  | "_" - math(<=atom)<m1> - "^" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m2; down_right = Some m1 } }
  | "^" - math(<=atom)<m1>
      { fun i -> { i with up_right = Some m1 } }
  | "_" - math(<=atom)<m1>
      { fun i -> { i with down_right = Some m1 } }

spaces:
    { if not (has_space dyp) then raise Giveup }

math:
    (['a'-'z''A'-'Z'])<name>
      { Var(name) } atom
  | (['a'-'z''A'-'Z']['a'-'z''A'-'Z']+)<name> 
      { Fun(name) } atom
  | (['0'-'9']+('.'['0'-'9']+)?) <num> 
      {Num num } atom
  | [ "(" | "[" | "\\{" | "<" ]<op> math<a> [ ")" | "]" | "}" | ">"]<cl> 
      { Delim(op,a,cl) } atom 
  | "{" math<a> "}" 
      { a } atom 
  | leftind<i> - math(<ind)<m> - rightind<fi>
      { Indices(fi i, m) } ind
  | math(<=fun)<m> - rightind<fi>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
        Indices(fi d, m) } ind
  | math(<=fun)<a> - math(<fun)<b>
      { Apply(a, b) } fun
  | math(<=sum)<a> addition_like<op> math(<sum)<b>
      { Binary(2, a, false, op, false, b) } sum
  | prefix<op> math(<sum)<b> 
      { Prefix(3,op,false,b) } sum
  | math(<sum)<b> postfix<op>
      { Postfix(3,b,true,op) } sum
  | math(<=prod)<a> product_like<op> math(<prod)<b> 
      { Binary(3, a, false, op, false, b) } prod
  | math(<=prod)<a> - spaces math(<prod)<b>
      { Binary(3, a, false, "", false, b) } prod
  | math(<=rel)<a> relation<op> math(<rel)<b> 
      { Binary(1, a, false, op, false, b) } rel
  | math(<=conj)<a> connector<op> math(<conj)<b> 
      { Binary(0, a, false, op, false, b) } conj
  | math(<=impl)<a> arrow<op> math(<impl)<b> 
      { Binary(0, a, false, op, false, b) } impl
  | math(<=punc)<a> punctuation<op> math(<punc)<b> 
      { Binary(2, a, true, op, false, b) } punc
  | symbol<name>
      { Symbol(name) } atom

symbol_name:
	([^' ''{''}''\t''\n''\r']+) { $1 }

atomelt:
  /* Section */
  | newline - (("="|"-")">")<o> ['_']?<num> newline? paragraph<title> [newline]* text<content> [newline]* (("="|"-")">")<c>
    { if o.[0] <> c.[0] then raise Giveup;
      [Struct(title, o.[0] = '=', Relative (List.rev content))]
    }
  | newline - (("=""="+)|("-""-"+))<o> ['_']?<num> newline? paragraph<title> newline? 
              (("=""="+)|("-""-"+))<c>
    { let level = String.length o in
      if c <> o then raise Giveup;
      [Struct(title,  o.[0] = '=', Absolute (level - 1))] }
  /* Code Caml */
  | newline - CAML<s,e>
    { [Caml(s,e)] }
  /* verbatim / source code */
  | newline - "'''" [ lident|uident ]?<lang> newline
    [ - (verbatim_line)<l> - newline {l}]*<ls>
    - "'''"
    { [Verbatim(lang, ls)] }
  /* Top level macros \Begin or \Ident */
  | newline - topmacro<m>
    { [m] }
  /* Math en display style */
  | "$$" math<m> "$$"
    { [Math m] }
  /* Symbol extension */
  | "\\Add_relation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "relation" (fun x -> Obj_relation x) names value }
  | "\\Add_addition_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "addition_like" (fun x -> Obj_addition_like x) names value }
  | "\\Add_product_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "product_like" (fun x -> Obj_product_like x) names value }
  | "\\Add_connector" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "connector" (fun x -> Obj_connector x) names value }
  | "\\Add_arrow" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "arrow" (fun x -> Obj_arrow x) names value }
  | "\\Add_punctuation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "punctuation" (fun x -> Obj_punctuation x) names value }
  | "\\Add_prefix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "prefix" (fun x -> Obj_prefix x) names value }
  | "\\Add_postfix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "postfix" (fun x -> Obj_postfix x) names value }
  | "\\Add_symbol" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" "{" symbol_name<value> "}"
    @{ add_symbol_rule dyp.local_data "symbol" (fun x -> Obj_symbol x) names value }
  | "\\Save_Grammar" "{"  lident<name> "}"
    { let oc = open_out_bin (name ^ gram_ext) in
      let ld = { dyp.local_data with verbose = false } in
      Marshal.to_channel oc (ld, dyp.parser_pilot.pp_dev) [ Marshal.Closures ];
      close_out oc;
      [Ignore]
    } 
  | "\\Verbose_Changes" 
    @{ [Ignore], [Local_data { dyp.local_data with verbose = true }] }
  | paragraph<p> { [Paragraph p] }
     

/* BUG + TOO SLOW 
partext:
  | partext<t> newline [newline]+ paragraph<p> 
    @{ (Paragraph p::t), [ Keep_grammar; Local_data dyp.local_data ]}
  | text<t> [newline]* paragraph<p> 
    @{ (Paragraph p::t), [ Keep_grammar; Local_data dyp.local_data ]}

text:
  | { [] }
  | partext<t> [newline]* atomelt<p> 
   @{ (p::t), [ Keep_grammar; Local_data dyp.local_data ]}
  | text<t> [newline]* atomelt<p> 
   @{ (p::t), [ Keep_grammar; Local_data dyp.local_data ]}

main:
  | grammar [ [newline]* title ]?<p> text<t> [newline]* eof
    { (p, List.rev t) }
  | grammar [ [newline]* title ]?<p> partext<t> [newline]* eof
    { (p, List.rev t) }
  
*/

/* BUG + TOO SLOW TOO 
text:
  | { [] } endatom
  | text<t> [newline]* atomelt<p> 
   @{ (p::t), [ Keep_grammar; Local_data dyp.local_data ]} endatom
  | text(=endatom)<t> [newline]* paragraph<p> 
    @{ (Paragraph p::t), [ Keep_grammar; Local_data dyp.local_data ]} endpar
  | text(=endpar)<t> newline [newline]+ paragraph<p> 
    @{ (Paragraph p::t), [ Keep_grammar; Local_data dyp.local_data ]} endpar

main:
  | grammar [ [newline]* title ]?<p> text<t> [newline]* eof
    { (p, List.rev t) }
*/

text:
  | { [] }
  | text<t> [newline]*<ln> atomelt<p> 
   @{ begin match t, p, ln with
        (Paragraph _ :: _), (Paragraph _::_), ([] | [_]) -> raise Giveup
      | _ -> ()
      end;
      (p @ t), [ Keep_grammar; Local_data dyp.local_data ]}

main:
  | grammar [ [newline]* title ]?<p> text<t> [newline]* eof
    { (p, List.rev t) }
  