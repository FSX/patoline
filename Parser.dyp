
{
open Lexing
open Dyp

exception Syntax_Error of Lexing.position * string

let set_newline dyplexbuf =
  let l = Dyp.std_lexbuf dyplexbuf in
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
(* let dypgen_choose_token = `all *)

let dyp_merge = keep_one

type math =
     Var of string
   | Fun of string
   | Num of string   
   | Prefix of string * math
   | Postfix of string * math
   | Binary of string * math * math
   | Indices of indices * math
   | Apply of math * math

and indices = { up_right : math option;
    down_right : math option; 
    up_left : math option;
    down_left : math option }

type doc =
     Paragraph of content list
   | Verbatim of (string option * string list)
   | Caml of int * int
   | Struct of content list * doc list
   | Macro of [ `Single | `Module | `Begin | `End ] * string * doc list
   | Math of math  

and content =
     TC of string
   | FC of math
   | MC of [ `Single | `Module | `Begin | `End ] * string * doc list

let comment_depth = ref 0 let push_comment () = incr comment_depth
let caml_depth = ref 0 let push_caml () = incr caml_depth
let pop_comment () = decr comment_depth; !comment_depth = 0
let pop_caml () = decr caml_depth; !caml_depth = 0
let pop_caml' lexbuf =
     decr caml_depth; 
     if !caml_depth = 0	then
      raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Splitted end of caml code"))

let concat words =
    let non_word  = [  "(" ; ")" ; "[" ; "]" ; "{" ; "}" ; "'"; "\""  ] in
    let rec fn acc last = function
      [] -> acc
    | (w::l) ->
       let last' = List.mem w non_word in
       let acc = if last' || last then w ^ acc else w ^" "^acc in
       fn acc last' l
    in fn "" true (List.rev words) 
       
}

%start main

%relation atom < fun < ind < sum < prod < rel < neg < conj < impl
%relation nonatom

%layout [ ' ' '\r' '\t' ]

%lexer

let utf8_char =
    ['\033' '\035' '\037'-'\038' '\042'-'\090' '\096'-'\122' '\124''\126''\127']
  | ['\194'-'\223']['\129'-'\191']
  | ['\224'-'\238']['\129'-'\191']['\129'-'\191']
  | '\239'['\129'-'\159']['\129'-'\191']
  | ['\240'-'\243']['\129'-'\191']['\129'-'\191']['\129'-'\191']
  | '\244'['\129'-'\143']['\129'-'\191']['\129'-'\191']

let string = '"' ([^'"'] | "\\\"")* '"'

let newline = '\r'* '\n' '\r'*

let verbatim_line = (''' ''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    (''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    ([^'\n' '\r' '''] [^'\n''\r']*) | 
		    (''' '''?)

let lident = ['a'-'z'] ['a'-'z''A'-'Z''0'-'9''_']*

let uident = ['A'-'Z'] ['a'-'z''A'-'Z''0'-'9''_']*

rule comment = parse
    '*' ')' {  if pop_comment () then () else comment lexbuf }
  | '(' '*' {  push_comment (); comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unterminated comment")) }
  | '\n' {  set_newline lexbuf; comment lexbuf }
  | string {  comment lexbuf }
  | _ {  comment lexbuf }

and caml = parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unexpected end of comment")) }
  | '}' '}' { pop_caml' lexbuf ; if pop_caml () then () else caml lexbuf } 
  | '}' { pop_caml' lexbuf; caml lexbuf } 
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; caml lexbuf } 
  | '{' { push_caml (); caml lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,"Unterminated comment")) }
  | '\n' { set_newline lexbuf; caml lexbuf }
  | string { caml lexbuf }
  | _ { caml lexbuf }

main lexer =
  newline -> NEWLINE { set_newline lexbuf }
  '(' '*' -> { push_comment (); comment lexbuf }
  '{' '{' -> CAML { let l = Dyp.std_lexbuf lexbuf in 
		    let start = l.lex_start_p.pos_cnum + 2 in 
		    push_caml (); push_caml (); caml lexbuf;
		    start, l.lex_start_p.pos_cnum
		  }
  '\\' "Begin" -> BEGIN
  '\\' "End" -> END
  '\\' lident
    -> PMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '\\' uident
    -> TMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '='+ -> SECT { Dyp.lexeme lexbuf }
  utf8_char+ | '(' | ')' | '[' | ']' | '{' | '}' | '^' | '_' | ''' | '"' | '$' 
       -> WORD { Dyp.lexeme lexbuf }

%parser

paragraph:
    WORD+<w> { [TC (concat w)] }
  | WORD+<w> [NEWLINE]? paragraph<p> { TC (concat w) :: p }
  | parmacro<m> { [ m ] }
  | parmacro<m> [NEWLINE]? paragraph<p> { m :: p }
  | "$" math<m> "$" { [FC m] }
  | "$" math<m> "$" [NEWLINE]? paragraph<p> { FC m :: p }
 
preambule:
  [NEWLINE]*
	{ None }
| - SECT<st> [NEWLINE]*
  paragraph<title> [NEWLINE]*
  [ parskip paragraph<author> [NEWLINE]* 
    [parskip paragraph]?<institute> [NEWLINE]* {author, institute} ]?<at> 
  - SECT<en> [NEWLINE]*    
  { if String.length st < 10 or String.length en < 10 then raise Giveup;
    Some(title,at) }

parskip:
  | NEWLINE [NEWLINE]+

ptext:
  /* empty */
    {[]}
  | parskip text<t>
    { t }

textp:
    { [] }
  | text(=nonatom)<t> parskip
    { t }

textn:
    { [] }
  | text<t> [NEWLINE]*
    { t }

args:
    /* empty */
    { [] }
  | "{" paragraph<p> "}" [NEWLINE]? args<a>
    { Paragraph p::a }
  | CAML<s,e> [NEWLINE]? args<a>
    { Caml(s,e) :: a }

topmacro:
    BEGIN "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" [NEWLINE]? args<a>
      { Macro(`Begin, name, a) }
  | END "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" [NEWLINE]? args<a>
      { Macro(`End, name, a) }
  | TMACRO<name> [NEWLINE]? args<a>
      { Macro(`Module, name, a) }

parmacro:
  | PMACRO<name> [NEWLINE]? args<a>
      { MC(`Single, name, a) }

leftind:
  | math(<=atom)<m1> - "^^" - math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = Some m1; down_right = None; down_left = Some m2 } }
  | math(<=atom)<m1> - "__" - math(<=atom)<m2> - "^^" 
      { { up_right = None; up_left = Some m2; down_right = None; down_left = Some m1 } }
  | math(<=atom)<m1> - "^^"
      { { up_right = None; up_left = Some m1; down_right = None; down_left = None } }
  | math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = None; down_right = None; down_left = Some m2 } }

rightind:
    /* empty */
      { (fun i -> i) }
  | "^" - math(<=atom)<m1> - "_" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m1; down_right = Some m2 } }
  | "_" - math(<=atom)<m1> - "^" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m2; down_right = Some m1 } }
  | "^" - math(<=atom)<m1>
      { fun i -> { i with up_right = Some m1 } }
  | "_" - math(<=atom)<m1>
      { fun i -> { i with down_right = Some m1 } }

math:
    (['a'-'z''A'-'Z'])<name>
      { Var(name) } atom
  | (['a'-'z''A'-'Z']['a'-'z''A'-'Z']+)<name> 
      { Fun(name) } atom
  | (['-''+']?['0'-'9']+('.'['0'-'9']+)?) <num> 
      {Num num } atom
  | "(" math<a> ")" 
      { a } atom 
  | leftind<i> - math(<ind)<m> - rightind<fi>
      { Indices(fi i, m) } ind
  | math(<=fun)<m> - rightind<fi>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
        Indices(fi d, m) } ind
  | math(<=fun)<a> - "(" math<b> ")"
      { Apply(a, b) } fun
  | math(<=sum)<a> ["+"|"-"]<op> math(<sum)<b>
      { Binary(op, a, b) } sum
  | ["+"|"-"]<op> math(<sum)<b> 
      { Prefix(op,b) } sum
  | math(<=prod)<a> ["*"|"/"]<op> math(<prod)<b> 
      { Binary(op, a, b) } prod
  | math(<=prod)<a>  math(<prod)<b>
      { Binary("*", a, b) } prod
  | math(<=rel)<a> ["="|"<="|">="]<op> math(<rel)<b> 
      { Binary(op, a, b) } rel
  | "!"<op> math(<neg)<a>
      { Prefix(op, a) } neg
  | math(<=conj)<a> ["&&"|"||"]<op> math(<conj)<b> 
      { Binary(op, a, b) } conj
  | math(<=impl)<a> ["=>"|"<=>"]<op> math(<impl)<b> 
      { Binary(op, a, b) } impl


text:
  /* Section */
  | textn<t> - "=>" NEWLINE? paragraph<title> ptext<content> [NEWLINE]* "=<"
    { Struct(title, List.rev content) :: t } atom
  /* Code Caml */
  | textn<t> CAML<s,e>
    { Caml(s,e) :: t } atom
  /* Top level macros \Begin or \Ident */
  | textn<t> topmacro<m>
    { m :: t } atom
  /* verbatim / source code */
  | textn<t> - "'''" [ lident|uident ]?<lang> NEWLINE
    [ - (verbatim_line)<l> - NEWLINE {l}]*<ls>
    - "'''" [NEWLINE]*
    { Verbatim(lang, ls) :: t } atom
  /* paragraphs : two cases */
  | textp<t> paragraph<p>
    { Paragraph p :: t } nonatom
  | text(=atom)<t> [NEWLINE]* paragraph<p>
    { Paragraph p :: t } nonatom
  /* Math en display style */
  | textn<t> "$$" math<m> "$$"
    { Math m :: t } atom

main:
  | preambule<p> text<t> [NEWLINE]* eof
    { p, List.rev t }
  
