{
open Lexing
open Dyp
open Config

exception Syntax_Error of Lexing.position * Language.syntax_error

let set_newline nb dyplexbuf =
  let l = Dyp.std_lexbuf dyplexbuf in
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + nb; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
let dypgen_choose_token = `all

let dyp_merge = keep_all

exception File_not_found of (string*string list)
let findPath f path=
  let rec findPath f=function
      []->raise (File_not_found (f,path))
    | h::s when Sys.file_exists (Filename.concat h f)->(Filename.concat h f)
    | h::s -> (findPath f s)
  in
    findPath f path
let findGrammar f=findPath f ("." :: (!grammarsdir))


module Str = struct
  type t = string
  let compare = compare
end

module StrSet = Set.Make(Str)
module StrMap=Map.Make(Str)
type local_data = { infixes : StrSet.t;  other_symbols : StrSet.t; verbose : bool }

type math =
     Var of string
   | Symbol of symbol
   | Fun of string
   | Num of string
   | Prefix of int * symbol * bool * math
   | Postfix of int * math * bool * symbol
   | Binary of int * math * bool * symbol * bool * math
   | Indices of indices * math
   | Apply of math * math
   | MathMacro of string * math list
   | Delim of symbol * math * symbol
   | MScope of math list
and indices = { up_right : math option;
    down_right : math option;
    up_left : math option;
    down_left : math option }
and symbol=
    SimpleSym of string
  | Over
  | CamlSym of string


and structType = Absolute of int | Relative of doc list

and doc =
     Paragraph of content list
   (* FIXME : construct the type of the parsing device instead of Obj.t *)
   | Caml of local_data * Obj.t * int * int * (texprime_section * int * int) list
   | Math of math
   | Verbatim of string option * string list
   | Struct of content list * bool * structType
   | Macro of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string * doc list
   | Preproc of string
   | Ignore

and texprime_section = TxpMath | TxpText

and content =
     TC of string
   | FC of bool * math
   | MC of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string * doc list
   | GC
let par_macros:(string->content list) StrMap.t ref=ref StrMap.empty
let macros:(string->string) StrMap.t ref=ref StrMap.empty



let comment_depth = ref 0 let push_comment () = incr comment_depth
let caml_depth = ref 0 let push_caml () = incr caml_depth
let texprime_math_depth = ref 0 let push_texprime_math () = incr texprime_math_depth
let texprime_text_depth = ref 0 let push_texprime_text () = incr texprime_text_depth
let pop_comment () = decr comment_depth; !comment_depth = 0
let pop_caml () = decr caml_depth; !caml_depth
let pop_texprime_math () = decr texprime_math_depth; !texprime_math_depth = 0
let pop_texprime_text () = decr texprime_text_depth; !texprime_text_depth = 0

let has_space dyp =
    let next = dyp.next_lexeme () in
    match next with
      [] -> false
    | s::_ when s<>"" && (s.[0]='\n' or s.[0] = ' ' or s.[0] = '\t') -> true
    | [_] -> false
    | _ -> true 

let concat words =
    let non_word  = [  "#"; "(" ; ")" ; "[" ; "]" ; "{" ; "}" ; "$"; "\""; "^"; "_"; "-"  ] in
    let rec fn acc last = function
      [] -> acc
    | (w::l) ->
       let last' = List.mem w non_word in
       let acc = if last' || last then w ^ acc else w ^" "^acc in
       fn acc last' l
    in fn "" true (List.rev words) 


let local_data = { infixes = StrSet.empty; other_symbols = StrSet.empty; verbose = false }

let add_symbol_rule local_data rule_name rule_constr symbols (symbol_value:symbol) =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched _ ] -> rule_constr symbol_value, []
    | _ -> assert false
  in
  let elt = if not local_data.verbose then [Ignore] else
    [Ignore; Paragraph
      [FC (false, Binary(0, Symbol symbol_value, false, SimpleSym "⇐", false,
      List.fold_right (fun s acc -> 
        let elt = Symbol (SimpleSym (String.escaped s)) in
        if acc = Var "" then elt else
	  Binary(0, elt, true, SimpleSym ",", false, acc)) symbols (Var "")))]] 
  in
  elt, [Add_rules[rule, action]; Local_data local_data]

let gram_ext = if Dynlink.is_native then ".tgx" else ".tgo"

let reserved = [ "Begin"; "End"; "No_Grammar"; "Use_Grammar"; "Include"; "Caml"; 
    	         "Add_relation"; "Add_addition_like"; "Add_product_like" ]

let fprint_caml_buf = ref (Obj.repr (fun _ -> assert false))

}

%start main 
%start allparagraph
%start allmath 

%relation args < atom < fun < ind < prod < sum < rel < neg < conj < impl < punc
%relation endany < endatom
%relation endany < endpar

%lexer

let utf8_char =
  ['\033' '\037'-'\039' '\042'-'\044' '\046'-'\060' '\062'-'\090' '\096'-'\122' '\124''\126''\127']
  | ['\194'-'\223']['\129'-'\191']
  | ['\224'-'\238']['\129'-'\191']['\129'-'\191']
  | '\239'['\129'-'\159']['\129'-'\191']
  | ['\240'-'\243']['\129'-'\191']['\129'-'\191']['\129'-'\191']
  | '\244'['\129'-'\143']['\129'-'\191']['\129'-'\191']

let space = [' ' '\t' '\r']
let newline = '\n'

let string = '"' ([^'"'] | "\\\"")* '"'

let verbatim_line = (''' ''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    (''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    ([^'\n' '\r' '''] [^'\n''\r']*) | 
		    (''' '''?)

let lident = ['a'-'z'] ['a'-'z''A'-'Z''0'-'9']*

let uident = ['A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*

let filename = ['a'-'z''A'-'Z''0'-'9' '.' '-']*

let sword = '(' | ')' | '[' | ']' | '"' | "=" | '-'

let word = utf8_char+

let line = sword | (word (space+ word)*)

rule comment = parse
    '*' ')' {  if pop_comment () then () else comment lexbuf }
  | '(' '*' {  push_comment (); comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_comment)) }
  | newline {  set_newline 1 lexbuf; comment lexbuf }
  | string {  comment lexbuf }
  | _ {  comment lexbuf }

and caml txps= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | ')' { if pop_caml () <= 0 then txps else caml txps lexbuf } 
  | '"' ([^'"'] | "\\\"")* '"' { caml txps lexbuf }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; caml txps lexbuf } 
  | '(' { push_caml (); caml txps lexbuf } 
  | '<' '$' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      push_texprime_math () ; 
	      flush stdout; 
	      texprime_math lexbuf; 
	      caml ((TxpMath, start, l.lex_start_p.pos_cnum) :: txps) lexbuf } 
  | '<' '<' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      push_texprime_text () ; 
	      flush stdout; 
	      texprime_text lexbuf; 
	      caml ((TxpText, start, l.lex_start_p.pos_cnum) :: txps) lexbuf } 
  | eof { [] }
  | newline { set_newline 1 lexbuf; caml txps lexbuf }
  | string { caml txps lexbuf }
  | _ { caml txps lexbuf }

and texprime_math= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | '$' '>' { if pop_texprime_math () then () else texprime_math lexbuf }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; texprime_math lexbuf } 
  | '<' '$' { push_texprime_math (); texprime_math lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_math)) }
  | newline { set_newline 1 lexbuf; texprime_math lexbuf }
  | string { texprime_math lexbuf }
  | _ { texprime_math lexbuf }

and texprime_text= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | '>''>' {  if pop_texprime_text () then () else texprime_text lexbuf }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; texprime_text lexbuf } 
  | '<''<' {  push_texprime_text (); texprime_text lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_text)) }
  | newline {  set_newline 1 lexbuf; texprime_text lexbuf }
  | string {  texprime_text lexbuf }
  | _ {  texprime_text lexbuf }

main lexer =
  space ->
  newline -> { set_newline 1 lexbuf }
  newline -> NEWLINE { set_newline 1 lexbuf; "" }
  newline (space* newline) -> PARSKIP { set_newline 2 lexbuf; "" }
  '\\' "Begin" -> BEGIN
  '\\' "End" -> END
  '\\' "Include" -> INCLUDE
  '\\' lident
    -> PMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '\\' uident
    -> TMACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '#' lident
    -> PPRE { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '#' uident
    -> TPRE { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '(' '*' -> { push_comment (); comment lexbuf }
  '(' -> CAML { let l = Dyp.std_lexbuf lexbuf in
		    let start = l.lex_start_p.pos_cnum + 1 in 
		    push_caml ();
		    let txps= caml [] lexbuf in
		    print_int start; print_string ", ";
		    print_int l.lex_start_p.pos_cnum; print_newline ();
		    start, l.lex_start_p.pos_cnum, List.rev txps
		  }
  
%parser

parelt:
   parmacro<m> { m, has_space dyp }
  | "$" math<m> "$" { [FC(false,m)], has_space dyp  }
  | line<w> { [TC w], has_space dyp  }


paragraph:
  | 
    { [], false }
  | paragraph<p,sp> parelt<e,sp'> 
    { e@(if sp then GC::p else p), sp' }

eparagraph: 
   paragraph<p,_> { List.rev p }

allparagraph:
   eparagraph<p> eof { p }

nparagraph:
  | parelt<e,sp> 
    { e, sp }
  | nparagraph<p,sp> parelt<e,sp'> 
    { e@(if sp then GC::p else p), sp' }

pparagraph: 
   nparagraph<p,_> [ PARSKIP | eof ] 
   { List.rev p }

memo_grammar: 
     { 
        let ld = { dyp.local_data with verbose = false } in
        let gr = dyp.parser_pilot.pp_dev in
	ld, Obj.repr gr
     }

args:
    /* empty */
     { (fun ld gr  -> []) } 
  | "()"
    { (fun ld gr  -> []) } 
  | args<a> - "{" eparagraph<p> "}" 
    { (fun ld gr -> Paragraph (p)::a ld gr) } 
  | args<a> - CAML<s,e,txps>
    { if e - s <= 2 then raise Giveup; 
      (fun ld gr -> Caml(ld,gr,s,e,txps) :: a ld gr) } 

neargs:
  | "()"
    { (fun ld gr  -> []) }
  | "{" eparagraph<p> "}" 
    { (fun ld gr -> [Paragraph (p)]) }
  | CAML<s,e,txps>
    { if e - s <= 2 then raise Giveup; 
      (fun ld gr -> [Caml(ld,gr,s,e,txps)]) }
  | neargs<a> - "{" eparagraph<p> "}" 
    { (fun ld gr -> Paragraph (p)::a ld gr) }
  | neargs<a> - CAML<s,e,txps>
    { if e - s <= 2 then raise Giveup; 
      (fun ld gr -> Caml(ld,gr,s,e,txps) :: a ld gr) }

topmacro:
    BEGIN "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" memo_grammar<ld,gr> args<a>
      { Macro(`Begin, name, List.rev (a ld gr)) }
  | END "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" memo_grammar<ld,gr> args<a>
      { Macro(`End, name, List.rev (a ld gr)) }
  | INCLUDE "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}"
      { Macro(`Include,name,[]) }
  | TMACRO<name> - memo_grammar<ld,gr> - args<a>
      { if List.mem name reserved then raise Giveup;
        Macro(`Module, name, List.rev (a ld gr)) }
  | TPRE<preproc> '{' preproc<text> '}'
      { try
          let name=
            if Sys.file_exists (Printf.sprintf "%s.cmxs" preproc) then
              (Printf.sprintf "%s.cmxs" preproc)
            else
              (Printf.sprintf "%s%s.cmxs"(String.lowercase (String.sub preproc 0 1))
                 (String.sub preproc 1 (String.length preproc-1)))
          in
            Dynlink.loadfile (Dynlink.adapt_filename name);
            let f=StrMap.find preproc !macros in
            let t=String.concat "" text in
              Preproc (f t)
        with
            Not_found ->Printf.fprintf stderr "Error while dynlinking toplevel macro %s\n" preproc;
	      flush stderr ; raise Not_found
          | Dynlink.Error x as e->(Printf.fprintf stderr
                                     "Dynlink error : %s\n" (Dynlink.error_message x);raise e)
      }
preproc:
      {[]}
  | '{' preproc<a> '}' preproc<b> { ("{"::a)@("}"::b) }
  | (utf8_char | space)*<a> preproc<b> {a::b}


parmacro:
  | PMACRO<name> - memo_grammar<ld,gr> - neargs<a>
      { [MC(`Single, name, List.rev (a ld gr))] }  macro
  | PMACRO<name> space+
      { [MC(`Single, name, [])] } args
  | PPRE<preproc> - memo_grammar<ld,gr> - CAML<s,e,txps>
      { [MC (`Preproc, preproc, [Caml (ld,gr,s,e,txps)])]
      }
  | PPRE<preproc> '{' preproc<text> '}'

      { try
          Dynlink.loadfile (Dynlink.adapt_filename (Printf.sprintf "%s.cmo" preproc));
          let f=StrMap.find preproc !par_macros in
          let t=String.concat "" text in
            f t
        with
            Not_found ->Printf.fprintf stderr "Error while dynlinking %s\n" preproc;
	      flush stderr ; raise Not_found
          | Dynlink.Error x as e->(Printf.fprintf stderr
                                     "Dynlink error : %s\n" (Dynlink.error_message x);raise e)
      }

leftind:
  | math(<=atom)<m1> - "^^" - math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = Some m1; down_right = None; down_left = Some m2 } }
  | math(<=atom)<m1> - "__" - math(<=atom)<m2> - "^^" 
      { { up_right = None; up_left = Some m2; down_right = None; down_left = Some m1 } }
  | math(<=atom)<m1> - "^^"
      { { up_right = None; up_left = Some m1; down_right = None; down_left = None } }
  | math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = None; down_right = None; down_left = Some m2 } }

rightind:
  | "^" - math(<=atom)<m1> - "_" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m1; down_right = Some m2 } }
  | "_" - math(<=atom)<m1> - "^" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m2; down_right = Some m1 } }
  | "^" - math(<=atom)<m1>
      { fun i -> { i with up_right = Some m1 } }
  | "_" - math(<=atom)<m1>
      { fun i -> { i with down_right = Some m1 } }

promath:
    math(<=prod)<m> { m, has_space dyp }

allmath:
   math<m> eof { m }

mathargs:
  /* empty */
    { (fun ld gr  -> []) } atom
  | "()"
    { (fun ld gr  -> []) } args
  | mathargs<a> - "{" math<m> "}"
    { (fun ld gr -> m::a ld gr) }  args
/*  | mathargs<a> - CAML<s,e,txps>
    { if e - s <= 2 then raise Giveup; 
      (fun ld gr -> Caml(ld,gr,s,e,txps) :: a ld gr) } */
nemathargs:
    "()"
    { (fun ld gr  -> []) } args
  | "{" math<m> "}"
    { (fun ld gr ->[ m]) }  args
  | nemathargs<a> - "{" math<m> "}"
    { (fun ld gr -> m::a ld gr) }  args


math:
   (['a'-'z''A'-'Z'])<name>
      { Var(name) } atom
  | (['a'-'z''A'-'Z']['a'-'z''A'-'Z']+)<name> 
      { Fun(name) } atom
  | (['0'-'9']+('.'['0'-'9']+)?) <num> 
      {Num num } atom
  | left<op> math<a> right <cl>
      { Delim(op,a,cl) } atom
  | "\\{" math<a> "\\}"
      { Delim(SimpleSym "{",a,SimpleSym "}") } atom
  | "{" math<a> "}"
      { a } atom
  | leftind<i> - math(<ind)<m> [- rightind]?<fi>
      { let fi = match fi with None -> (fun x -> x) | Some f -> f in
        Indices(fi i, m) } ind
  | math(<=fun)<m> - rightind<fi>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
        Indices(fi d, m) } ind
  | math(<=fun)<a> - math(<fun)<b>
      { Apply(a, b) } fun
  | math(<=sum)<a> addition_like<op> math(<sum)<b>
      { Binary(2, a, false, op, false, b) } sum
  | "\\" [lident|uident]<macro> - memo_grammar<ld,gr> - nemathargs<args> 
      { MathMacro (macro,args ld gr) } args
  | "\\" [lident|uident]<macro> - memo_grammar<ld,gr> - mathargs<args> space+
      { MathMacro (macro,args ld gr) } atom
  | prefix<op> math(<sum)<b> 
      { Prefix(3,op,false,b) } sum
  | math(<sum)<b> postfix<op>
      { Postfix(3,b,true,op) } sum
  | math(<=prod)<a> product_like<op> math(<prod)<b> 
      { Binary(3, a, false, op, false, b) } prod
  | promath<a, sp> math(<prod)<b>
      { if not sp then raise Giveup; Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=prod)<a> "*" math(<prod)<b>
      { Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=rel)<a> relation<op> math(<rel)<b> 
      { Binary(1, a, false, op, false, b) } rel
  | math(<=conj)<a> connector<op> math(<conj)<b> 
      { Binary(0, a, false, op, false, b) } conj
  | math(<=impl)<a> arrow<op> math(<impl)<b> 
      { Binary(0, a, false, op, false, b) } impl
  | math(<=punc)<a> punctuation<op> math(<punc)<b> 
      { Binary(2, a, true, op, false, b) } punc
  | symbol<name>
      { Symbol(name) } atom

symbol_name:
    ([^' ''{''}''\t''\n''\r''\\''#']+)<sym>

symbol_def:
    memo_grammar<ld,gr> CAML<s,e,txps> {
      let buf = Buffer.create 80 in  
      Obj.magic !fprint_caml_buf ld gr buf s e txps;
      CamlSym(Buffer.contents buf)
    }
  | '{' symbol_name<sym> '}' { SimpleSym sym }

atomelt:
  /* Section */
  | (("="|"-")">")<o> ['_']?<num> eparagraph<title> PARSKIP text<content> (("="|"-")"<")<c>
    { if o.[0] <> c.[0] then raise Giveup;
      [Struct(title, o.[0] = '=', Relative (List.rev content))]
    }
  | (("=""="+)|("-""-"+))<o> eparagraph<title>
      (("=""="+)|("-""-"+))<c>
    { let level = String.length o in
      if level >= 10 then raise Giveup;
      if c <> o then raise Giveup;
      [Struct(title,  o.[0] = '=', Absolute (level - 1))] }
  | "\"\"\"" [ lident|uident ]?<lang> NEWLINE
    [ - (verbatim_line)<l> - NEWLINE {l}]*<ls>
    "\"\"\""
    { [Verbatim(lang, ls)] }
  /* Code Caml */
  | "\\Caml" memo_grammar<ld,gr> CAML<s,e,txps>
    { [Caml(ld,gr,s,e,txps)] }
  /* Top level macros \Begin or \Ident */
  | topmacro<m>
    { [m] }
  /* Symbol extension */
  | "\\Add_relation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "relation" (fun x -> Obj_relation x) names value }
  | "\\Add_addition_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
      "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "addition_like" (fun x -> Obj_addition_like x) names value }
  | "\\Add_product_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "product_like" (fun x -> Obj_product_like x) names value }
  | "\\Add_connector" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "connector" (fun x -> Obj_connector x) names value }
  | "\\Add_arrow" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "arrow" (fun x -> Obj_arrow x) names value }
  | "\\Add_punctuation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "punctuation" (fun x -> Obj_punctuation x) names value }
  | "\\Add_prefix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "prefix" (fun x -> Obj_prefix x) names value }
  | "\\Add_postfix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "postfix" (fun x -> Obj_postfix x) names value }
  | "\\Add_symbol" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "symbol" (fun x -> Obj_symbol x) names value }
  | "\\Add_left" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "left" (fun x -> Obj_left x) names value }
  | "\\Add_right" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "right" (fun x -> Obj_right x) names value }
  | "\\Save_Grammar" "{"  lident<name> "}"
    { let oc = open_out_bin (name ^ gram_ext) in
      let ld = { dyp.local_data with verbose = false } in
      Marshal.to_channel oc (ld, dyp.parser_pilot.pp_dev) [ Marshal.Closures ];
      close_out oc;
      [Ignore]
    } 
  | "$$" math<m> "$$" { [Math(m)] }
  | "\\Verbose_Changes" 
    @{ [Ignore], [Local_data { dyp.local_data with verbose = true }] }

atomeltp:
    atomelt<e> [NEWLINE]* @{ e, [ Keep_grammar; Local_data dyp.local_data ] }
/*  | eparagraph<p> NOSKIP atomelt<e> @{ Paragraph(p)::e, [ Keep_grammar; Local_data dyp.local_data ] }*/
  | pparagraph<p> @{ [Paragraph(p)], [ Keep_grammar; Local_data dyp.local_data ] }

title:
  ("=========="('='*))
    line+<title>
     [PARSKIP line+<author>
      [PARSKIP line+]?<institute> {author, institute} ]?<at>
  ("=========="('='*))
  { title,at }

text:
  | { [] }
  | text<t> atomeltp<p>
   @{ p@t, [ Keep_grammar; Local_data dyp.local_data ]}

grammar_aux:
    { Some "patolineDefault" }
  | "\\Use_Grammar{" filename<name> "}"
    { Printf.fprintf stderr "Some\n"; Some name }
  | "\\No_Grammar"
    { Printf.fprintf stderr "None\n"; None }

grammar: grammar_aux<g>
    @{ let action = match g with
           (* Patch temporaire : on ne charge pas de grammaire s'il n'y a pas de chemin,
              pour éviter les "code mismatch". L'option --no-grammar de TeX' contrôle ça *)
        Some filename when !Config.grammarsdir <> []-> (
	  try
	    let grammar_name = findGrammar (filename ^ gram_ext) in
	    let ic = open_in grammar_name in
	    let local_data, grammar = input_value ic in
	    close_in ic;
	    Printf.fprintf stderr "Grammar: %s.\n" grammar_name ;
	    [ Local_data local_data; Parser grammar ]
          with e -> Printf.fprintf stderr "No Grammar Loaded (%s).\n" (Printexc.to_string e); []
        )
      | _->[]
       in
       (), action
    }

main:
  | grammar [title]?<p> text<t> eof
    { (p, List.rev t) }
