/*
  Copyright Tom Hirschowitz, Florian Hatat, Pierre-Etienne Meunier,
  Christophe Raffalli and others, 2012.

  This file is part of Patoline.

  Patoline is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Patoline is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Patoline.  If not, see <http://www.gnu.org/licenses/>.
*/
{
open Lexing
open Dyp
open Config
open Util

exception Syntax_Error of Lexing.position * Language.syntax_error
exception Outdated

let set_newline nb l =
  let pos = l.lex_curr_p in
  let nb=if pos.pos_cnum=1 then nb-1 else nb in
  let npos = { pos with pos_lnum = pos.pos_lnum + nb; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
let dypgen_choose_token = `all
let dyp_merge = keep_one

let findGrammar f=findPath f ("." :: (!grammarspath))
let out_grammar_name=ref ""

let grammar=ref (Some "DefaultGrammar")


type macro_info = [ 
  `Eat_left
| `Eat_right
| `Arg_pat of (int * string)
| `Arg_nopar of int
| `Is_idt
| `Nb_args of int
| `Fun_name of string
| `Give_pos
]

type local_data = { 
     infixes : StrSet.t;
     other_symbols : StrSet.t;
     verbose : bool; 
     word_macros : (string * macro_info list) list;
     par_macros : (string * macro_info list) list;
     env_macros : (string * macro_info list) list;
     math_macros : (string * macro_info list) list;
}

type 'a math =
     Var of string
   | Symbol of symbol
   | Fun of string
   | Num of string
   | Prefix of int * symbol * bool * 'a math
   | Operator of string * 'a math
   | Limits_operator of string * 'a math
   | Postfix of int * 'a math * bool * symbol
   | Binary of int * 'a math * bool * symbol * bool * 'a math
   | Indices of 'a indices * 'a math
   | Apply of 'a math * 'a math
   | MathMacro of string * 'a math list
   | MathCaml of local_data * 'a * int * int * (texprime_section * int * int * int * int) list
     * (string * int * int)
   | Delim of string * 'a math * string
   | MScope of 'a math list
   | MathString of string

and 'a indices = { up_right : 'a math option;
    down_right : 'a math option;
    up_left : 'a math option;
    down_left : 'a math option }
and symbol=
    SimpleSym of string
  | CamlSym of string

and 'a structType = Absolute of int | Relative of 'a doc list

and paragraph_options = { 
    center_paragraph : bool; indent_paragraph : bool }

and toc=Toc_num | Toc_unnum | Not_in_toc

and 'a doc =
     Paragraph of paragraph_options * 'a content list
   | Caml of local_data * 'a * int * int * (texprime_section * int * int * int * int) list 
     * (string * int * int)
   | Math of string * 'a math
   | Verbatim of string option * string option * string list
   | Struct of 'a content list * toc * 'a structType
   | Macro of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string 
     * 'a doc list * macro_info list
   | Preproc of string
   | String of string
   | Ignore

and texprime_section = TxpMath | TxpText

and 'a content =
     TC of string * string
   | FC of string * bool * 'a math
   | MC of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string 
           * 'a doc list * macro_info list
   | GC


let default_paragraph_options = { center_paragraph = false; indent_paragraph = true; }
let sParagraph c = Paragraph(default_paragraph_options, c)
let niParagraph c = Paragraph({default_paragraph_options with indent_paragraph = false}, c)


let concat words =
    let non_word  = [  "#"; "(" ; ")" ; "[" ; "]" ; "{" ; "}" ; "$"; "\""; "^"; "_"; "-"  ] in
    let rec fn acc last = function
      [] -> acc
    | (w::l) ->
       let last' = List.mem w non_word in
       let acc = if last' || last then w ^ acc else w ^" "^acc in
       fn acc last' l
    in fn "" true (List.rev words) 


let local_data = { 
    infixes = StrSet.empty;
    other_symbols = StrSet.empty;
    verbose = false;
    word_macros = [];
    par_macros = [];
    env_macros = [];
    math_macros = [];
}

let quail = Lazy.lazy_from_fun (fun () ->
    let ch = open_out_bin "quail.el" in
    ch)

let no_ind = { up_right = None; up_left = None; down_right = None; down_left = None }

let app_ind d m = 
    if d = no_ind then m else Indices(d,m)

let add_symbol_rule local_data rule_name rule_constr symbols symbol_value =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"; "accent"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
(*       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;*)
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched l ] -> rule_constr (l, symbol_value, no_ind), []
    | _ -> assert false
  in
  let has_utf8 = ref None in
  let elt = if not local_data.verbose then [Ignore] else
    [niParagraph
      [FC ("", false, Binary(0, Symbol symbol_value, false, SimpleSym "⇐", false,
      List.fold_right (fun s acc ->
       let utflen = try CamomileLibrary.UTF8.validate s; CamomileLibrary.UTF8.length s
             with _ -> -1
       in	     
	if utflen = 1 && String.length s > 1 then has_utf8 := Some s;
        let elt = 
	  if utflen = 1 && 
	     (match symbol_value with SimpleSym _ -> false | _ -> true) then
	    Symbol symbol_value
	  else	     
  	    Symbol (SimpleSym (String.escaped s))
        in
        if acc = Var "" then elt else
	  Binary(0, elt, true, SimpleSym ",", false, acc)) symbols (Var "")))]]
  in
  begin
    match !has_utf8 with
      None -> ()
    | Some s ->
      List.iter (fun s' ->  
         if String.length s' > 1 && (try
            for i = 0 to String.length s' - 1 do if Char.code s'.[i] > 127 then raise Exit done;
	    true with Exit -> false)
         then (
(*	   Printf.fprintf stderr "(\"%s\" ?%s)\n" s' s;*)
	   Printf.fprintf (Lazy.force quail) "(\"%s\" ?%s)\n" (String.escaped s') s)) symbols
  end;
  (elt, [rule, action]), [Local_data local_data]

let add_multi_symbol_rule local_data rule_name rule_constr symbols symbol_value =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"; "accent"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
(*       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;*)
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched l ] -> rule_constr(symbol_value), []
    | _ -> assert false
  in
  let has_utf8 = ref None in
  let elt = if not local_data.verbose then [Ignore] else
    [niParagraph
      [FC ("", false, Binary(0, Symbol (CamlSym ("(fun x y -> List.flatten (Maths.multi_glyphs (" ^ symbol_value ^ ") x y))")), false, SimpleSym "⇐", false,
      List.fold_right (fun s acc ->
       let utflen = try CamomileLibrary.UTF8.validate s; CamomileLibrary.UTF8.length s
             with _ -> -1
       in	     
       if utflen = 1 && String.length s > 1 then has_utf8 := Some s;
       let elt = 
	  if utflen = 1 then
	    Symbol (CamlSym("List.hd ("^symbol_value^")"))
	  else	     
  	    Symbol (SimpleSym (String.escaped s))
       in
       if acc = Var "" then elt else
	  Binary(0, elt, true, SimpleSym ",", false, acc)) symbols (Var "")))]]
  in
  begin
    match !has_utf8 with
      None -> ()
    | Some s ->
      List.iter (fun s' ->  
         if String.length s' > 1 && s' <> s && (try
            for i = 0 to String.length s' - 1 do if Char.code s'.[i] > 127 then raise Exit done;
	    true with Exit -> false)
         then (
(*	   Printf.fprintf stderr "(\"%s\" ?%s)\n" s' s;*)
	   Printf.fprintf (Lazy.force quail) "(\"%s\" ?%s)\n" (String.escaped s') s)) symbols
  end;
  (elt, [rule, action]), [Local_data local_data]

let add_combining_symbol local_data symbol macro =
  let rule = ("math", [ Non_ter ("var_or_symbol", No_priority);
                           Regexp (RE_String symbol)  ], "atom", [No_layout_inside]) in
  let action dyp l =
    match l with
      [ Obj_var_or_symbol x;  Lexeme_matched _;] ->
      Obj_math (MathMacro(macro, [x])), []
    | _ -> assert false
  in
  let elt = if not local_data.verbose then [Ignore] else
    [niParagraph
      [FC ("", false, Binary(0, MathMacro(macro, [Var("x")]), false, SimpleSym "⇐", false,
        	    Symbol (SimpleSym (String.escaped ("\\"^macro)))))]]
  in
  (elt, [rule, action]), []

let gram_ext = ".tgx"

let reserved = [ "Begin"; "begin"; "end"; "End"; "Include"; "Caml";
    	         "Add_relation"; "Add_addition_like"; "Add_product_like"; "left"; "right"; "cr";
	         "verb";]

let fprint_caml_buf = ref (fun _ _ _ _ _ _ _ -> ((assert false):unit))


let rec list_last = function
  [] -> assert false
  | [x] -> x
  | x :: l -> list_last l
let arg_paren = ['{'; '(']
let rien = '}'				(* Sinon dypgen a l'impression qu'on n'a pas ferme le truc ci-dessus :)) *)
let next_lexeme_paren l = 
  match l with 
    | [] -> false
    | _ -> 
      let last = list_last l in
      if String.length last = 0 then false else
	let last = last.[0] in begin
	  (* Printf. fprintf stderr "next lexeme: %c\n" (last) ; *)
	  (* flush stderr ; *)
	  List.mem last arg_paren
	end

let layout_info dyp a b =
    (*let a' = dyp.rhs_start_pos a in
    let b' = dyp.rhs_end_pos b in*)
    let a = dyp.rhs_end_pos a in
    let b = dyp.rhs_start_pos b in
    let cdiff = b.pos_cnum - a.pos_cnum in
    let ldiff = b.pos_lnum - a.pos_lnum in
    let margin = b.pos_cnum - b.pos_bol in
    (*Printf.fprintf stderr "[%d: %d - %d: %d]  [%d: %d - %d: %d]\n" a'.pos_lnum a'.pos_cnum a.pos_lnum a.pos_cnum b.pos_lnum b.pos_cnum b'.pos_lnum b'.pos_cnum; *)
    cdiff, ldiff, margin

let get_pos_as_string dyp a =
    let a = dyp.rhs_start_pos a in
    Printf.sprintf "(\"%s\",%d,%d,%d)"
      (String.escaped a.pos_fname)
      a.pos_lnum
      (a.pos_cnum - a.pos_bol)
      a.pos_cnum

let get_pos_as_tuple dyp a =
    let a = dyp.rhs_start_pos a in
    Printf.fprintf stderr "line: %d\n" a.pos_lnum;
    ( (String.escaped a.pos_fname),
      a.pos_lnum,
      (a.pos_cnum - a.pos_bol),
      a.pos_cnum)

let layout_parskip dyp a b =
    let c,l,m = layout_info dyp a b in l > 1 (* or (l = 1 && m > 1) *)

let layout_space dyp a b =
    let c,l,m = layout_info dyp a b in c > 0

let get_local_data_and_grammar dyp =
        let ld = { dyp.local_data with verbose = false } in
        let gr = dyp.parser_pilot.pp_dev in
	ld, gr

let get_wminfo dyp name =
  try List.assoc name dyp.local_data.word_macros with Not_found -> []

let get_pminfo dyp name =
  try List.assoc name dyp.local_data.par_macros with Not_found -> []

let get_eminfo dyp name =
  try List.assoc name dyp.local_data.env_macros with Not_found -> []

let get_mminfo dyp name =
  try List.assoc name dyp.local_data.math_macros with Not_found -> []

let get_nbargs name l =
    let rec fn = function
      [] -> raise Not_found
    | `Nb_args n::_ -> n
    | _::l -> fn l
    in
    fn (List.assoc name l)
  
let fix_name name l =
  let rec fn = function
    [] -> raise Not_found
  | `Fun_name n::_ -> n
  | h::l -> fn l
  in
  try fn (List.assoc name l) with Not_found -> name

let give_pos name l =
  try List.mem `Give_pos (List.assoc name l) with Not_found -> false

let test_wargs dyp name a =
    if List.mem name reserved then raise Giveup;
    let ld, gr = get_local_data_and_grammar dyp in
    let terminated, args = a ld gr in
    let args = if give_pos name dyp.local_data.word_macros then
      String (get_pos_as_string dyp 1)::args else args
    in    
    begin
      try	
        let l = get_nbargs name dyp.local_data.word_macros in
        if l <> List.length args then raise Giveup;
      with Not_found ->
        if not terminated && next_lexeme_paren (dyp.next_lexeme ()) then raise Giveup
   end;
   fix_name name dyp.local_data.word_macros, args

let test_pargs dyp name a =
    if List.mem name reserved then raise Giveup;
    let ld, gr = get_local_data_and_grammar dyp in
    let terminated, args = a ld gr in
    let args = if give_pos name dyp.local_data.word_macros then
      String(get_pos_as_string dyp 1)::args else args
    in    
    begin
      try	
        let l = get_nbargs name dyp.local_data.par_macros in
        if l <> List.length args then raise Giveup;
      with Not_found ->
        if not terminated && next_lexeme_paren (dyp.next_lexeme ()) then raise Giveup
   end;
   fix_name name dyp.local_data.word_macros, args

let test_eargs dyp name a =
    let ld, gr = get_local_data_and_grammar dyp in
    let terminated, args = a ld gr in
    let args = if give_pos name dyp.local_data.env_macros then
      String(get_pos_as_string dyp 1)::args else args
    in    
    begin
      try	
        let l = get_nbargs name dyp.local_data.env_macros in
        if l <> List.length args then raise Giveup;
      with Not_found ->
        if not terminated && next_lexeme_paren (dyp.next_lexeme ()) then raise Giveup
   end;
   fix_name name dyp.local_data.word_macros, args

let test_margs dyp name a =
    if List.mem name reserved then raise Giveup;
    let name' = "\\"^name in
    if StrSet.mem name' dyp.local_data.other_symbols ||
       StrSet.mem name' dyp.local_data.infixes
    then raise Giveup;
    let ld, gr = get_local_data_and_grammar dyp in
    let terminated, args = a ld gr in
    let args = if give_pos name dyp.local_data.math_macros then
      MathString(get_pos_as_string dyp 1)::args else args
    in    
    begin
      try	
        let l = get_nbargs name dyp.local_data.math_macros in
        if l <> List.length args then raise Giveup;
      with Not_found ->
        if not terminated && next_lexeme_paren (dyp.next_lexeme ()) then raise Giveup
   end;
   fix_name name dyp.local_data.math_macros, args


}

%start main 
%start allparagraph
%start allmath 

%relation macro < atom < accent < ind < fun < prod < sum < operator < rel < neg < conj < impl < punc
%relation endany < endatom
%relation endany < endpar

%layout [' ' '\t' '\r']
%layout '\n' { set_newline 1 (std_lexbuf lexbuf) }

%lexer

let utf8_char =
  ['\033' '\037'-'\039' '\042'-'\044' '\046'-'\060' '\062'-'\090' '\096'-'\122' '\124''\127']
  | ['\194'-'\223']['\128'-'\191']
  | ['\224'-'\238']['\128'-'\191']['\128'-'\191']
  | '\239'['\128'-'\159']['\128'-'\191']
  | ['\240'-'\243']['\128'-'\191']['\128'-'\191']['\129'-'\191']
  | '\244'['\128'-'\143']['\128'-'\191']['\128'-'\191']

let space = [' ' '\t' '\r']
let newline = '\n'

let string = '"' ([^ '\\' '"'] | ("\\" _) )* '"'
let num = ['0'-'9']+('.'['0'-'9']+)?

let verbatim_line = '#'? '#'? [^'\n' '\r' '#'] [^'\n''\r']*

let ident = ['a'-'z''A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*
let lident = ['a'-'z'] ['a'-'z''A'-'Z''0'-'9']*
let uident = ['A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*
let mathvar = ['a'-'z''A'-'Z']

let filename = ['a'-'z''A'-'Z''0'-'9''.''-']*

let sword = '(' | ')' | '[' | ']' | '"' | "=" | '-'

let word = utf8_char+

let line = sword | (word (space+ word)*)

rule comment = parse
    '*' ')' {  () }
  | '(' '*' {  comment lexbuf; comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_comment)) }
  | newline {  set_newline 1 (std_lexbuf lexbuf); comment lexbuf }
  | string {  
      String.iter (fun c->if c='\n' then set_newline 1 (std_lexbuf lexbuf))
        (Dyp.lexeme lexbuf);
      comment lexbuf }
  | _ {  comment lexbuf }

and caml txps= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | ')' { txps } 
  | string {
        String.iter (fun c->if c='\n' then set_newline 1 (std_lexbuf lexbuf))
          (Dyp.lexeme lexbuf);
        caml txps lexbuf
    }
  | '(' '*' { comment lexbuf; caml txps lexbuf } 
  | '(' { let txps = caml txps lexbuf in caml txps lexbuf } 
  | '<' '$' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      texprime_math lexbuf; 
	      (* FIXME : why +2 below ? *)
	      let col = l.lex_start_p.pos_cnum - l.lex_start_p.pos_bol + 2 in
	      caml ((TxpMath, start, l.lex_start_p.pos_cnum, l.lex_start_p.pos_lnum, col) :: txps) lexbuf } 
  | '<' '<' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      texprime_text lexbuf; 
	      (* FIXME : why +2 below ? *)
	      let col = l.lex_start_p.pos_cnum - l.lex_start_p.pos_bol + 2 in
	      caml ((TxpText, start, l.lex_start_p.pos_cnum, l.lex_start_p.pos_lnum, col) :: txps) lexbuf } 
  | eof { [] }
  | newline { set_newline 1 (std_lexbuf lexbuf); caml txps lexbuf }
  | _ { caml txps lexbuf }

and texprime_math= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | '$' '>' { () } 
  | '(' '*' { comment lexbuf; texprime_math lexbuf } 
  | '<' '$' { texprime_math lexbuf; texprime_math lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_math)) }
  | newline { set_newline 1 (std_lexbuf lexbuf); texprime_math lexbuf }
  | string { 
          String.iter (fun c->if c='\n' then set_newline 1 (std_lexbuf lexbuf))
            (Dyp.lexeme lexbuf);
          texprime_math lexbuf }
  | _ { texprime_math lexbuf }

and texprime_text= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unexpected_end_of_comment)) }
  | '>' '>' { () }
  | '(' '*' { comment lexbuf; texprime_text lexbuf } 
  | '<' '<' {  texprime_text lexbuf; texprime_text lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,Language.Unterminated_text)) }
  | newline {  set_newline 1 (std_lexbuf lexbuf); texprime_text lexbuf }
  | string {
           String.iter (fun c->if c='\n' then set_newline 1 (std_lexbuf lexbuf))
            (Dyp.lexeme lexbuf);
           texprime_text lexbuf }
  | _ {  texprime_text lexbuf }

main lexer =
  '\\' ['B''b'] "egin" -> BEGIN
  '\\' ['E''e'] "nd" -> END
  '\\' "Include" -> INCLUDE
  '\\' ident
    -> MACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '(' '*' -> { comment lexbuf }
  '(' -> CAML { let l = Dyp.std_lexbuf lexbuf in
		    let start = l.lex_start_p.pos_cnum + 1 in 
		    let lstart = l.lex_start_p.pos_lnum in 
		    let cstart = start - l.lex_start_p.pos_bol in 
		    let txps= caml [] lexbuf in
(*		    Printf.fprintf stderr "%d, %d\n" start l.lex_start_p.pos_cnum;*)
		    start, (l.lex_start_p.pos_fname, lstart, cstart),
		     l.lex_start_p.pos_cnum, List.rev txps
		  }
  newline -> NEWLINE { set_newline 1 (std_lexbuf lexbuf) }
  newline "=="'='?'='?'='?'='?'='?'='?'='?'='? -> ABS_SECTION { 
    set_newline 1 (std_lexbuf lexbuf); 
    let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  newline "--"'-'?'-'?'-'?'-'?'-'?'-'?'-'?'-'? -> ABS_SECTION { 
    set_newline 1 (std_lexbuf lexbuf); 
    let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  "=="'='?'='?'='?'='?'='?'='?'='?'='? -> END_ABS_SECTION { Dyp.lexeme lexbuf }
  "--"'-'?'-'?'-'?'-'?'-'?'-'?'-'?'-'? -> END_ABS_SECTION { Dyp.lexeme lexbuf }

  newline ('='|'-'|'.') ">" -> START_SECTION {
    set_newline 1 (std_lexbuf lexbuf);
    let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1)
  }
  newline ("=========="'='*) -> TITLE {
    let l = Dyp.lexeme lexbuf in
    set_newline 1 (std_lexbuf lexbuf);
    String.sub l 1 (String.length l - 1)
  }

  newline ('='|'-'|'.') "<" -> END_SECTION { 
    set_newline 1 (std_lexbuf lexbuf); 
    let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }

  newline ("----------"'-'*) -> TITLESEP {
    set_newline 1 (std_lexbuf lexbuf); 
    let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  newline "###" -> VERBATIM { set_newline 1 (std_lexbuf lexbuf) }

  eof -> EOF

%parser

verb_text:
  | { [] }
  | verb_text<t> - "\\\\"  { TC("","\\")::t }
  | verb_text<t> - ("\\"[^'{''}''\\'])<s>  { TC("",s)::t }
  | verb_text<t> - "\\}"  { TC("","}")::t }
  | verb_text<t> - "\\{"  { TC("","{")::t }
  | verb_text<t> - "\\("  { TC("","(")::t }
  | verb_text<t> - "\\)"  { TC("",")")::t }
  | verb_text<t> - "{" - verb_text<t'> - "}"  { TC("","}")::t'@(TC("","{")::t) }
  | verb_text<t> - ([^'\\''{''}']*)<s>  { TC("", s)::t }
 
parelt:
    in_par_macro<m> { m, false }
  | line<w> { [TC (get_pos_as_string dyp 1, w)], false }
  | "\\{" { [TC("","{")], false }
  | "\\\\"  { [TC("", "\\")], false }
  | "\\$"  { [TC("", "$")], false }
  | "\\}"  { [TC("", "}")], false }
  | "~"  { [TC("", " ")], false }
  | "\\_"  { [TC("", "_")],false }
  | "\\~"  { [TC("", "~")], false }
  | "\\ "  { [TC("", " ")], false }
  | "\\verb{" verb_text<t> "}"
    { [MC(`Single, "verb", [sParagraph(List.rev t)], [])], false }
  | "_" paragraph_aux<p,false> "_"
    { [MC(`Single, "toggleItalic", [sParagraph(List.rev p)], [])], true }
  | "$" math<m> "$" { [FC(get_pos_as_string dyp 1, false,m)], false }
  | "[$" math<m> "$]" { [FC(get_pos_as_string dyp 1, false, MathMacro("displayStyle",[m]))], false }


paragraph_aux:
  | parelt<e, b>
    { e, b }
  | paragraph_aux<p, b> parelt<e, b'>   
    { 
      let c,l,m = layout_info dyp 1 2 in
      if p <> [] && (l > 1 (* or (l = 1 && m > 1) *)) then raise Giveup;
      (e@(if c > 0 then GC::p else p)), b or b' }

paragraph: 
   paragraph_aux<p, _> { List.rev p }

oparagraph: {[]} | paragraph<p> {p}

allparagraph:
   paragraph<p> "#$@#$@" { p }

word_macro: MACRO<name>
  { let test =
      (List.mem_assoc name dyp.local_data.word_macros ||
      let c = Char.code name.[0] in
      (Char.code 'a' <= c && c <= Char.code 'z')) &&
     not (List.mem_assoc name dyp.local_data.par_macros)
    in
    if not test then raise Giveup;
    name }    

par_macro: MACRO<name>
  { let test =
      (List.mem_assoc name dyp.local_data.par_macros  ||
      let c = Char.code name.[0] in
      (Char.code 'A' <= c && c <= Char.code 'Z'))
     &&    
      not (List.mem_assoc name dyp.local_data.word_macros)
    in
    if not test then raise Giveup;
    name }    
      
test<b>:
	{ if not b then raise Giveup; }

args<nb>:
    /* empty */
     { if nb > 0 then raise Giveup; (fun (ld:local_data) gr  -> false, []) } 
  | - "()"
    { if nb > 0 then raise Giveup; (fun (ld:local_data) gr  -> true, []) }
  | - "{" oparagraph<p> "}"
    { if nb <> 1 then raise Giveup; (fun ld gr -> true, [sParagraph (p)]) } 
  | - CAML<s,pos,e,txps> 
    { if nb <> 1 then raise Giveup; (fun ld gr -> true, [Caml(ld,gr,s,e,txps,pos)]) } 
  | - "{" oparagraph<p> "}" - test{nb>1 || nb < 0} - args{nb-1}<a>
    { (fun ld gr -> let b,l = a ld gr in b, (sParagraph (p)::l)) } 
  | - CAML<s,pos,e,txps> - test{nb>1 || nb < 0} - args{nb-1}<a>
    { (fun ld gr -> let b,l = a ld gr in b, (Caml(ld,gr,s,e,txps,pos) :: l)) } 

mathargs<nb>:
  /* empty */
    { if nb > 0 then raise Giveup; (fun (ld:local_data) gr  -> false, []) } 
  | - "()"
    { if nb > 0 then raise Giveup; (fun (ld:local_data) gr  -> true, []) }
  | - "{" math<m> "}"
    { if nb <> 1 then raise Giveup; (fun ld gr -> true, [m]) }
  | - CAML<s,pos,e,txps>
    { if nb <> 1 then raise Giveup; (fun ld gr -> true, [MathCaml(ld,gr,s,e,txps,pos)]) }
  | - "{" math<m> "}" - test{nb>1 || nb < 0} - mathargs{nb-1}<a>
    { (fun ld gr -> let b,l = a ld gr in b, (m::l)) }
  | - CAML<s,pos,e,txps> - test{nb>1 || nb < 0} - mathargs{nb-1}<a>
    { (fun ld gr -> let b,l = a ld gr in 
             b, (MathCaml(ld,gr,s,e,txps,pos) :: l)) }

readenvargs<macro>:
      { 
            try	
      	      get_nbargs macro dyp.local_data.env_macros
	    with Not_found -> -2
      }

readwordargs<macro>:
      { 
            try	
      	      get_nbargs macro dyp.local_data.word_macros
	    with Not_found -> -2
      }

readparargs<macro>:
      { 
            try	
      	      get_nbargs macro dyp.local_data.par_macros
	    with Not_found -> -2
      }

topmacro:
    BEGIN "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" 
    - readenvargs{name}<nb> - args{nb}<a>
      {	let name, args = test_eargs dyp name a in
        Macro(`Begin, name, args, get_eminfo dyp name) }
  | END "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}"
      { Macro(`End, name, [], []) }
  | INCLUDE "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}"
      { Macro(`Include,name,[], []) }
  | par_macro<name> - readparargs{name}<nb> - args{nb}<a>
      {	let name, args = test_pargs dyp name a in
        Macro(`Module, name, args, get_pminfo dyp name) }


in_par_macro:
  | word_macro<name> - readwordargs{name}<nb> - args{nb}<a>
      { 
        let name, args = test_wargs dyp name a in
        [MC(`Single, name, args, get_wminfo dyp name)] }  macro

leftind:
  | math(<=atom)<m1> - "^^" - math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = Some m1; down_right = None; down_left = Some m2 } }
  | math(<=atom)<m1> - "__" - math(<=atom)<m2> - "^^" 
      { { up_right = None; up_left = Some m2; down_right = None; down_left = Some m1 } }
  | math(<=atom)<m1> - "^^"
      { { up_right = None; up_left = Some m1; down_right = None; down_left = None } }
  | math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = None; down_right = None; down_left = Some m2 } }

subind:
  | "_" - math(<=atom)<m1> { m1 }
  | subscripts<s> {
      try
(*        Printf.fprintf stderr "ind: %s\n" s;*)
        let lexbuf = Dyp.from_string dyp.parser_pilot s in	
        let obj = Dyp.lexparse dyp.parser_pilot "allmath" lexbuf in
        match obj with
        | (Obj_allmath docs, _) :: _ -> docs
        | _ -> assert false
      with _ -> raise Giveup }

superind:
  | "^" - math(<=atom)<m1> { m1 }
  | superscripts<s> {
      try
(*        Printf.fprintf stderr "exp: %s\n" s;*)
        let lexbuf = Dyp.from_string dyp.parser_pilot s in	
        let obj = Dyp.lexparse dyp.parser_pilot "allmath" lexbuf in
        match obj with
        | (Obj_allmath docs, _) :: _ -> docs
        | _ -> assert false
      with _ -> raise Giveup }

rightind:
  | superind<m1> - subind<m2>
      { fun i -> { i with up_right = Some m1; down_right = Some m2 } }
  | subind<m1> - superind<m2>
      { fun i -> { i with up_right = Some m2; down_right = Some m1 } }
  | superind<m1>
      { fun i -> { i with up_right = Some m1 } }
  | subind<m1>
      { fun i -> { i with down_right = Some m1 } }

subscripts:
    subscript<s> { s }
  | subscripts<s'> - subscript<s> { s' ^ s }

superscripts:
    superscript<s> { s }
  | superscripts<s'> - superscript<s> { s' ^ s }

allmath:
   math<m> "#$@#$@" { m }

var_or_symbol:
   (mathvar)<name>
      { Var(name) }
  | (num)<n>
      { Num(n) } 
  | symbol<_,name,d>
      { if d <> no_ind then raise Giveup;
        Symbol(name) }

left:
   "\\left" right<d> { d }
  |"\\left." { "[]" }

right:
   "\\right" left<d> { d }
   |"\\right." { "[]" }
 

addition_like:
  | addition_like<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - addition_like<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

product_like:
  | product_like<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - product_like<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

relation:
  | relation<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - relation<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

quantifier:
  | quantifier<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - quantifier<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

arrow:
  | arrow<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - arrow<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

connector:
  | connector<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - connector<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

negation:
  | negation<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - negation<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

postfix:
  | postfix<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - postfix<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

prefix:
  | prefix<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - prefix<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

punctuation:
  | punctuation<x,m,d> - rightind<fi>
      { 
        if d.down_right <> None || d.up_right <> None then raise Giveup;
        x, m, fi d
      }
  | leftind<d> - punctuation<x,m,d'>
      { if d' <> no_ind then raise Giveup;
        x, m, d
      }

readmathargs<macro>:
      { 
            try	
      	      get_nbargs macro dyp.local_data.math_macros
	    with Not_found -> -2
      }

math:
   (mathvar)<name>
      { Var(name) } atom
  | (['a'-'z''A'-'Z']['a'-'z''A'-'Z']+)<name> 
      { Fun(name) } atom
  | (num) <num> 
      {Num num } atom
  | left<op> math<a> right<cl>
      { Delim(op,a,cl) } atom

  | "{" math<a> "}"
      { a } atom

  | leftind<i> - math(<ind)<m> [- rightind]?<fi>
      { let fi = match fi with None -> (fun x -> x) | Some f -> f in
        Indices(fi i, m) } ind
  | math(<ind)<m> - rightind<fi>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
        Indices(fi d, m) } ind

  | quantifier<_,m,dq> math(<operator)<v> [ relation<_,r,d> math(<operator)<e> {r, e, d} ]?<c> [punctuation]?<p> math(<=operator)<b>
      { 
        match c, p with
        | None, None -> Binary(1,app_ind dq (Prefix(3,m,false,v)),false,SimpleSym "",false,b)
        | None, Some(_,p,d) -> app_ind d (Binary(1,app_ind dq (Prefix(3,m,false,v)),true,p,false,b))
        | Some(r,e,d), None -> Binary(1,app_ind dq (Prefix(2,m,false,app_ind d (Binary(2,v,false,r,false,e)))),
	                         false,SimpleSym "",false,b)
        | Some(r,e,d), Some(_,p,d') -> app_ind d' (Binary(1,app_ind dq (Prefix(2,m,false,app_ind d (Binary(2,v,false,r,false,e)))),
	                         true,p,false,b))
      } operator

  | leftind<i> - operator<m> [- rightind]?<fi> math(<=operator)<b>
      { let fi = match fi with None -> (fun x -> x) | Some f -> f in
        Indices(fi i, Operator(m,b)) } operator
  | operator<m> - rightind<fi> math(<=operator)<b>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
          Indices(fi d, Operator (m,b)) } operator
  | operator<m> math(<=operator)<b>
      { Operator (m,b) } operator

  | limits_operator<m> - rightind<fi> math(<=operator)<b>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
          Indices(fi d, Limits_operator (m,b)) } operator
  | limits_operator<m> math(<=operator)<b>
      { Limits_operator (m,b) } operator

  | math(<=fun)<a> - math(<fun)<b>
      { Apply(a, b) } fun
  | math(<=sum)<a> addition_like<_,op,d> math(<sum)<b>
      { app_ind d (Binary(2, a, false, op, false, b)) } sum
  | "\\" - (ident)<macro> - readmathargs{macro}<nb> - mathargs{nb}<args>
    {
    let macro, args = test_margs dyp macro args in
      MathMacro (macro, args) } atom
  | prefix<_,op,d> math(<sum)<b> 
      { app_ind d (Prefix(3,op,false,b)) } sum

  | math(<sum)<b> postfix<_,op,d>
      { app_ind d (Postfix(3,b,true,op)) } sum
  | math(<=accent)<b> accent<_,op,d>
      { Postfix(3,b,true,op) } accent
  | math(<=prod)<a> product_like<_,op,d> math(<prod)<b> 
      { app_ind d (Binary(3, a, false, op, false, b)) } prod
  | math(<=prod)<a> math(<prod)<b>
      { if not (layout_space dyp 1 2) then raise Giveup; Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=prod)<a> "*" math(<prod)<b>
      { Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=rel)<a> relation<_,op,d> math(<rel)<b> 
      { app_ind d (Binary(1, a, false, op, false, b)) } rel
  | negation<_,op,d> math(<=neg)<b>  
      { app_ind d (Prefix(0,op,false,b)) } neg
  | math(<=conj)<a> connector<_,op,d> math(<conj)<b> 
      { app_ind d (Binary(0, a, false, op, false, b)) } conj
  | math(<=impl)<a> arrow<_,op,d> math(<impl)<b> 
      { app_ind d (Binary(0, a, false, op, false, b)) } impl
  | math(<=punc)<a> punctuation<_,op,d> math(<punc)<b> 
      { app_ind d (Binary(1, a, true, op, false, b)) } punc

  | "{" addition_like<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" product_like<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" prefix<l,op,d> "}"
      { if StrSet.mem l dyp.local_data.infixes then raise Giveup; 
	app_ind d (Symbol op) } atom
  | "{" postfix<l,op,d> "}"
      { if StrSet.mem l dyp.local_data.infixes then raise Giveup; 
	app_ind d (Symbol op) } atom
  | "{" accent<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" arrow<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" connector<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" relation<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" quantifier<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" negation<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" punctuation<_,op,d> "}"
      { app_ind d (Symbol op) } atom
  | "{" operator<m> "}"
      { (Symbol (CamlSym (Printf.sprintf "List.hd (%s)" m))) } atom
  | "{" limits_operator<m> "}"
      { (Symbol (CamlSym (Printf.sprintf "List.hd (%s)" m))) } atom

  | "{" left<m> "}"
      { (Symbol (CamlSym (Printf.sprintf "List.hd (%s)" m))) } atom
  | "{" right<m> "}"
      { (Symbol (CamlSym (Printf.sprintf "List.hd (%s)" m))) } atom
  | symbol<_,name,d>
      { app_ind d (Symbol(name)) } atom

symbol_name:
    ([^' ''{''}''\t''\n''\r''\\''#']+)<sym>

symbol_def:
    CAML<s,pos,e,txps> {
      let ld, gr = get_local_data_and_grammar dyp in
      let buf = Buffer.create 80 in  
      !fprint_caml_buf ld gr buf s e txps pos;
      CamlSym(Buffer.contents buf)
    }
  | '{' symbol_name<sym> '}' { SimpleSym sym }

symbol_defs:
    CAML<s,pos,e,txps> {
      let ld, gr = get_local_data_and_grammar dyp in
      let buf = Buffer.create 80 in  
      !fprint_caml_buf ld gr buf s e txps pos;
      Buffer.contents buf
    }

macro_option:
  "eat_left" { `Eat_left }
| "eat_right" { `Eat_right }
| "is_identity" { `Is_idt }
| "give_position" { `Give_pos }
| "name" "=" ((['A'-'Z']['a'-'z']*'.')?['a'-'z''A'-'Z'] ['a'-'z''A'-'Z''0'-'9''_' ''']*)<s> { `Fun_name s }
| "arg_" - (['0'-'9']+)<i> "=" ['a'-'z''A'-'Z''0'-'9''_']+<s> { `Arg_pat(int_of_string i, s) }
| "arg_" - (['0'-'9']+)<i> "no_parenthesis" { `Arg_nopar(int_of_string i) }
| "arity" "=" (['0'-'9']+)<i> { `Nb_args(int_of_string i) }

macro_options:
  | { [] }
  | macro_options<l> macro_option<o> { o::l }

verbatim_lines:
  { [] }
| verbatim_lines<ls> NEWLINE (verbatim_line)<l> {l::ls}
| verbatim_lines<ls> NEWLINE {""::ls}

atomelt:
  /* Section */
  | START_SECTION<o> paragraph<title> text<content,rules> END_SECTION<c>
    @{ let content = List.rev content in
      (match content with 
        Paragraph _:: _ -> if not (layout_parskip dyp 2 3) then raise Giveup
      | _ -> ());
      if o.[0] <> c.[0] then raise Giveup;
      ([Struct(title,
               (match o.[0] with
                   '='->Toc_num
                 | '-'->Toc_unnum
                 | '.'->Not_in_toc
                 | _->raise Giveup),
               Relative content)],rules),
	[ Keep_grammar; Local_data dyp.last_local_data ]
    }
  | ABS_SECTION<o> paragraph<title> END_ABS_SECTION<c>
    { let level = String.length o in
      if level >= 10 then raise Giveup;
      if c <> o then raise Giveup;
      [Struct(title,
              (match o.[0] with
                  '='->Toc_num
                | '-'->Toc_unnum
                | '.'->Not_in_toc
                 | _->raise Giveup),
              Absolute (level - 1))], [] }
  | VERBATIM [ - (space*) - (ident) ]?<lang> [ - (space*) - string ]?<filename>  [ - (space*)]? -
    verbatim_lines<ls> - VERBATIM
    { [Verbatim(None, None (*lang, filename*), List.rev ls)], [] }
  /* Code Caml */
  | "\\Caml" CAML<s,pos,e,txps>
    { let ld, gr = get_local_data_and_grammar dyp in
      [Caml(ld,gr,s,e,txps,pos)], [] }
  /* Top level macros \Begin or \Ident */
  | topmacro<m>
    { [m], [] }
  /* Symbol extension */
  | "\\Add_relation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "relation" (fun x -> Obj_relation x) names value }
  | "\\Add_addition_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
      "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "addition_like" (fun x -> Obj_addition_like x) names value }
  | "\\Add_product_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "product_like" (fun x -> Obj_product_like x) names value }
  | "\\Add_connector" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "connector" (fun x -> Obj_connector x) names value }
  | "\\Add_negation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "negation" (fun x -> Obj_negation x) names value }
  | "\\Add_arrow" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "arrow" (fun x -> Obj_arrow x) names value }
  | "\\Add_punctuation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "punctuation" (fun x -> Obj_punctuation x) names value }
  | "\\Add_prefix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "prefix" (fun x -> Obj_prefix x) names value }
  | "\\Add_quantifier" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "quantifier" (fun x -> Obj_quantifier x) names value }
  | "\\Add_postfix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "postfix" (fun x -> Obj_postfix x) names value }
  | "\\Add_accent" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "accent" (fun x -> Obj_accent x) names value }
  | "\\Add_operator" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "operator" (fun x -> Obj_operator x) names value }
  | "\\Add_limits_operator" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "limits_operator" (fun x -> Obj_limits_operator x) names value }
  | "\\Add_symbol" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "symbol" (fun x -> Obj_symbol x) names value }
  | "\\Add_left" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "left" (fun x -> Obj_left x) names value }
  | "\\Add_left" "{" "\\{"<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "left" (fun x -> Obj_left x) [names] value }
  | "\\Add_right" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "right" (fun x -> Obj_right x) names value }
  | "\\Add_right" "{" "\\}"<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "right" (fun x -> Obj_right x) [names] value }
  | "\\Add_combining" "{" (utf8_char)<symbol> "}" "{" MACRO<m> "}"
    @{ add_combining_symbol dyp.local_data symbol m }
  | "\\Configure_word_macro" "{" '\\' - symbol_name<w> "}" "{" macro_options<o> "}"
    @{ ([Ignore], []), 
       [Local_data { dyp.local_data with word_macros = (w, o)::dyp.local_data.word_macros }]
     }
  | "\\Configure_math_macro" "{" '\\' - symbol_name<w> "}" "{" macro_options<o> "}"
    @{ ([Ignore], []),
       [Local_data { dyp.local_data with math_macros = (w, o)::dyp.local_data.math_macros }]
     }
  | "\\Configure_paragraph_macro" "{" '\\' - symbol_name<w> "}" "{" macro_options<o> "}"
    @{ ([Ignore], []), 
       [Local_data { dyp.local_data with par_macros = (w, o)::dyp.local_data.par_macros }]
     }
  | "\\Configure_environment" "{" symbol_name<w> "}" "{" macro_options<o> "}"
    @{ ([Ignore], []), 
       [Local_data { dyp.local_data with env_macros = (w, o)::dyp.local_data.env_macros }]
     }
  | "$$" math<m> "$$" { [Math(get_pos_as_string dyp 1, m)], [] }
  | "\\Verbose_Changes" 
    @{ ([Ignore], []), [Local_data { dyp.local_data with verbose = true }] }
  | "\\cr" { [Ignore], [] }


title:
  TITLE
    paragraph<title>
     [TITLESEP paragraph<author>
      [TITLESEP paragraph]?<institute> {author, institute} ]?<at>
  TITLE
  { title,at }

ntext_apply_grammar:
    ntext<t,rs> "\\Build_Grammar"
   @{ (t:'a list), [Add_rules rs; Local_data dyp.last_local_data ] }

ntext_save_grammar:
    ntext<t,rs> "\\Save_Grammar"
   @{ (t:'a list), [Add_rules rs; Local_data dyp.last_local_data ] }

ntext:
  | paragraph<p> 
     @{let _,_,m = layout_info dyp 1 1 in
       let options = { default_paragraph_options with center_paragraph = m >= 4 } in
       ([Paragraph(options, p)], []), [ Keep_grammar; Local_data dyp.last_local_data ] }
  | atomelt<t,r> 
     @{ (t, r), [ Keep_grammar; Local_data dyp.last_local_data ] }
  | ntext_apply_grammar<t> 
     @{ (t, []), [ Keep_grammar; Local_data dyp.last_local_data ] }     
  | ntext_save_grammar<t> 
    @{
      if !out_grammar_name <> "" then begin
	let oc = open_out_bin (!out_grammar_name^gram_ext) in
	let ld = { dyp.last_local_data with verbose = false } in
	Marshal.to_channel oc (ld, dyp.parser_pilot.pp_dev) [ Marshal.Closures ];
	close_out oc;
      end;
      (t,[]), [ Keep_grammar; Local_data dyp.last_local_data ]
    } 
  | ntext<t,rs> atomelt<p,r>
     @{ (p@t,r@rs), [ Keep_grammar; Local_data dyp.last_local_data ] }
  | ntext<t,rs> paragraph<p>
     @{ 
       (let _,_,m = layout_info dyp 2 2 in
       let opt = { default_paragraph_options with center_paragraph = m >= 4 } in
       (match t with 
       | (Paragraph _::_) ->
	  if not (layout_parskip dyp 1 2) then raise Giveup;
	  Paragraph(opt,p)::t
       | _ ->
          if not (layout_parskip dyp 1 2) then
	    Paragraph({opt with indent_paragraph = false},p)::t
	  else 
            Paragraph(opt,p)::t), rs)
       , [ Keep_grammar; Local_data dyp.last_local_data ]}


grammar:
    @{let action = match !grammar with
        Some filename when !Config.grammarspath <> [] -> (
	  try
	    let grammar_name =findGrammar (filename ^ gram_ext) in
	    let ic = open_in grammar_name in
	    let local_data, grammar = input_value ic in
	    close_in ic;
	    [ Local_data local_data; Parser grammar ]
          with
            | e ->(Printf.fprintf stderr "%s\n"
                     (Language.message (Language.No_grammar_loaded
                                          (filename^gram_ext,Printexc.to_string e)));
                   [])
        )
      | _->[]
      in

      (), action
    }

text: { [], [] } | ntext<t> @{ t, [ Keep_grammar; Local_data dyp.last_local_data ]}

caml_header:
  | "\\Caml" CAML<s,pos,e,txps>
  { let ld, gr = get_local_data_and_grammar dyp in
    Caml(ld,gr,s,e,txps,pos) }


main:
  grammar [caml_header]<a> [title]<p> text<t,_> EOF
    { (Some a, Some p, List.rev t) }

  | grammar [title]?<p> text<t,_> EOF
      { (None, p, List.rev t) }
