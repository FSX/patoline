{
open Lexing
open Dyp
open PatolineConfig

exception Syntax_Error of Lexing.position * PatolineLanguage.syntax_error
exception Outdated

let set_newline nb l =
  let pos = l.lex_curr_p in
  let npos = { pos with pos_lnum = pos.pos_lnum + nb; pos_bol = pos.pos_cnum } in
  l.lex_curr_p <- npos

(* very important to allow using regexp for special combination of characteres *)
let dypgen_choose_token = `all

let dyp_merge = keep_one

exception File_not_found of (string*string list)
let findPath f path=
  let rec findPath f=function
      []->raise (File_not_found (f,path))
    | h::s when Sys.file_exists (Filename.concat h f)->(Filename.concat h f)
    | h::s -> (findPath f s)
  in
    findPath f path
let findGrammar f=findPath f ("." :: (!grammarsdir))
let deps_only=ref None
let out_grammar_name=ref ""
let used_grammars=ref []

module Str = struct
  type t = string
  let compare = compare
end

module StrSet = Set.Make(Str)
module StrMap=Map.Make(Str)

type macro_info = [ `Eat_left | `Eat_right | `Arg_pat of (int * string) | `Arg_nopar of int | `Is_idt ]
type local_data = { 
     infixes : StrSet.t;
     other_symbols : StrSet.t;
     verbose : bool; 
     word_macros : (string * macro_info list) list;
     par_macros : (string * macro_info list) list;
     env_macros : (string * macro_info list) list;
}

type 'a math =
     Var of string
   | Symbol of symbol
   | Fun of string
   | Num of string
   | Prefix of int * symbol * bool * 'a math
   | Operator of string * 'a math
   | Limits_operator of string * 'a math
   | Postfix of int * 'a math * bool * symbol
   | Binary of int * 'a math * bool * symbol * bool * 'a math
   | Indices of 'a indices * 'a math
   | Apply of 'a math * 'a math
   | MathMacro of string * 'a math list
   | MathCaml of local_data * 'a * int * int * (texprime_section * int * int) list
   | Delim of string * 'a math * string
   | MScope of 'a math list
and 'a indices = { up_right : 'a math option;
    down_right : 'a math option;
    up_left : 'a math option;
    down_left : 'a math option }
and symbol=
    SimpleSym of string
  | CamlSym of string

and 'a structType = Absolute of int | Relative of 'a doc list

and paragraph_options = { center_paragraph : bool; useless_option : unit }

and 'a doc =
     Paragraph of paragraph_options * 'a content list
   | Caml of local_data * 'a * int * int * (texprime_section * int * int) list
   | Math of 'a math
   | Verbatim of string option * string list
   | Struct of 'a content list * bool * 'a structType
   | Macro of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string 
     * 'a doc list * macro_info list
   | Preproc of string
   | Ignore

and texprime_section = TxpMath | TxpText

and 'a content =
     TC of string
   | FC of bool * 'a math
   | MC of [ `Single | `Module | `Begin | `End | `Include | `Preproc ] * string 
           * 'a doc list * macro_info list
   | GC
let par_macros:(string->'a content list) StrMap.t ref=ref StrMap.empty
let macros:(string->string) StrMap.t ref=ref StrMap.empty

let default_paragraph_options = { center_paragraph = false; useless_option = (); }
let sParagraph c = Paragraph(default_paragraph_options, c)

let comment_depth = ref 0 let push_comment () = incr comment_depth
let caml_depth = ref 0 let push_caml () = incr caml_depth
let texprime_math_depth = ref 0 let push_texprime_math () = incr texprime_math_depth
let texprime_text_depth = ref 0 let push_texprime_text () = incr texprime_text_depth
let pop_comment () = decr comment_depth; !comment_depth = 0
let pop_caml () = decr caml_depth; !caml_depth
let pop_texprime_math () = decr texprime_math_depth; !texprime_math_depth = 0
let pop_texprime_text () = decr texprime_text_depth; !texprime_text_depth = 0

let concat words =
    let non_word  = [  "#"; "(" ; ")" ; "[" ; "]" ; "{" ; "}" ; "$"; "\""; "^"; "_"; "-"  ] in
    let rec fn acc last = function
      [] -> acc
    | (w::l) ->
       let last' = List.mem w non_word in
       let acc = if last' || last then w ^ acc else w ^" "^acc in
       fn acc last' l
    in fn "" true (List.rev words) 


let local_data = { 
    infixes = StrSet.empty;
    other_symbols = StrSet.empty;
    verbose = false;
    word_macros = [];
    par_macros = [];
    env_macros = [];
}

let quail = Lazy.lazy_from_fun (fun () ->
    let ch = open_out_bin "quail.el" in
    ch)

let add_symbol_rule local_data rule_name rule_constr symbols symbol_value =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"; "accent"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
(*       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;*)
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched _ ] -> rule_constr symbol_value, []
    | _ -> assert false
  in
  let has_utf8 = ref None in
  let elt = if not local_data.verbose then [Ignore] else
    [Ignore; sParagraph
      [FC (false, Binary(0, Symbol symbol_value, false, SimpleSym "⇐", false,
      List.fold_right (fun s acc ->
       let utflen = try CamomileLibrary.UTF8.validate s; CamomileLibrary.UTF8.length s
             with _ -> -1
       in	     
	if utflen = 1 && String.length s > 1 then has_utf8 := Some s;
        let elt = 
	  if utflen = 1 && 
	     (match symbol_value with SimpleSym _ -> false | _ -> true) then
	    Symbol symbol_value
	  else	     
  	    Symbol (SimpleSym (String.escaped s))
        in
        if acc = Var "" then elt else
	  Binary(0, elt, true, SimpleSym ",", false, acc)) symbols (Var "")))]]
  in
  begin
    match !has_utf8 with
      None -> ()
    | Some s ->
      List.iter (fun s' ->  
         if String.length s' > 1 && (try
            for i = 0 to String.length s' - 1 do if Char.code s'.[i] > 127 then raise Exit done;
	    true with Exit -> false)
         then (
(*	   Printf.fprintf stderr "(\"%s\" ?%s)\n" s' s;*)
	   Printf.fprintf (Lazy.force quail) "(\"%s\" ?%s)\n" (String.escaped s') s)) symbols
  end;
  elt, [Add_rules[rule, action]; Local_data local_data]

let add_multi_symbol_rule local_data rule_name rule_constr symbols symbol_value =
  let noinfix = List.mem rule_name ["symbol"; "prefix"; "postfix"; "accent"] in
  let adef = if noinfix then 
    local_data.other_symbols else local_data.infixes
  in  
  let newsyms =
    List.fold_left (fun acc s ->
(*       if StrSet.mem s acc then begin
         Printf.fprintf stderr "Symbol \"%s\" alread y exists.\n" s; 
         exit 1
       end;*)
       StrSet.add s acc) adef symbols
  in
  let local_data = if noinfix then { local_data with other_symbols = newsyms }
                              else { local_data with infixes = newsyms }
  in
  let regexp = RE_Alt (List.map (fun x -> RE_String x) symbols) in 
  let rule = (rule_name, [ Regexp regexp ], "default_priority", []) in
  let action dyp l =
    match l with
      [ Lexeme_matched _ ] -> rule_constr symbol_value, []
    | _ -> assert false
  in
  let has_utf8 = ref None in
  let elt = if not local_data.verbose then [Ignore] else
    [Ignore; sParagraph
      [FC (false, Binary(0, Symbol (CamlSym ("(fun x y -> List.flatten (Maths.multi_glyphs (" ^ symbol_value ^ ") x y))")), false, SimpleSym "⇐", false,
      List.fold_right (fun s acc ->
       let utflen = try CamomileLibrary.UTF8.validate s; CamomileLibrary.UTF8.length s
             with _ -> -1
       in	     
       if utflen = 1 && String.length s > 1 then has_utf8 := Some s;
       let elt = 
  	    Symbol (SimpleSym (String.escaped s))
       in
       if acc = Var "" then elt else
	  Binary(0, elt, true, SimpleSym ",", false, acc)) symbols (Var "")))]]
  in
  begin
    match !has_utf8 with
      None -> ()
    | Some s ->
      List.iter (fun s' ->  
         if String.length s' > 1 && s' <> s && (try
            for i = 0 to String.length s' - 1 do if Char.code s'.[i] > 127 then raise Exit done;
	    true with Exit -> false)
         then (
(*	   Printf.fprintf stderr "(\"%s\" ?%s)\n" s' s;*)
	   Printf.fprintf (Lazy.force quail) "(\"%s\" ?%s)\n" (String.escaped s') s)) symbols
  end;
  elt, [Add_rules[rule, action]; Local_data local_data]

let add_combining_symbol local_data symbol macro =
  let rule = ("math", [ Non_ter ("var_or_symbol", No_priority);
                           Regexp (RE_String symbol)  ], "atom", [No_layout_inside]) in
  let action dyp l =
    match l with
      [ Obj_var_or_symbol x;  Lexeme_matched _;] ->
      Obj_math (MathMacro(macro, [x])), []
    | _ -> assert false
  in
  let elt = if not local_data.verbose then [Ignore] else
    [Ignore; sParagraph
      [FC (false, Binary(0, MathMacro(macro, [Var("x")]), false, SimpleSym "⇐", false,
        	    Symbol (SimpleSym (String.escaped ("\\"^macro)))))]]
  in
  elt, [Add_rules[rule, action]]

let gram_ext = ".tgx"

let reserved = [ "Begin"; "begin"; "end"; "End"; "No_Grammar"; "Use_Grammar"; "Include"; "Caml"; 
    	         "Add_relation"; "Add_addition_like"; "Add_product_like"; "left"; "right"]

let fprint_caml_buf = ref (fun _ _ _ _ _ _ -> ((assert false):unit))


let rec list_last = function
  [] -> assert false
  | [x] -> x
  | x :: l -> list_last l
let arg_paren = ['{'; '(']
let rien = '}'				(* Sinon dypgen a l'impression qu'on n'a pas ferme le truc ci-dessus :)) *)
let next_lexeme_paren l = 
  match l with 
    | [] -> false
    | _ -> 
      let last = list_last l in
      if String.length last = 0 then false else
	let last = last.[0] in begin
	  (* Printf. fprintf stderr "next lexeme: %c\n" (last) ; *)
	  (* flush stderr ; *)
	  List.mem last arg_paren
	end

let layout_info dyp a b =
    (*let a' = dyp.rhs_start_pos a in
    let b' = dyp.rhs_end_pos b in*)
    let a = dyp.rhs_end_pos a in
    let b = dyp.rhs_start_pos b in
    let cdiff = b.pos_cnum - a.pos_cnum in
    let ldiff = b.pos_lnum - a.pos_lnum in
    let margin = b.pos_cnum - b.pos_bol in
    (*Printf.fprintf stderr "[%d: %d - %d: %d]  [%d: %d - %d: %d]\n" a'.pos_lnum a'.pos_cnum a.pos_lnum a.pos_cnum b.pos_lnum b.pos_cnum b'.pos_lnum b'.pos_cnum; *)
    cdiff, ldiff, margin

let layout_parskip dyp a b =
    let c,l,m = layout_info dyp a b in l > 1 (* or (l = 1 && m > 1) *)

let layout_space dyp a b =
    let c,l,m = layout_info dyp a b in c > 0

let get_local_data_and_grammar dyp =
        let ld = { dyp.local_data with verbose = false } in
        let gr = dyp.parser_pilot.pp_dev in
	ld, gr

let get_wminfo dyp name =
  try List.assoc name dyp.local_data.word_macros with Not_found -> []

let get_pminfo dyp name =
  try List.assoc name dyp.local_data.par_macros with Not_found -> []

let get_eminfo dyp name =
  try List.assoc name dyp.local_data.env_macros with Not_found -> []
}

%start main 
%start allparagraph
%start allmath 

%relation macro < args < atom < accent < ind < fun < prod < sum < operator < rel < neg < conj < impl < punc
%relation endany < endatom
%relation endany < endpar

%layout [' ' '\t' '\r']
%layout '\n' { set_newline 1 (std_lexbuf lexbuf) }

%lexer

let utf8_char =
  ['\033' '\037'-'\039' '\042'-'\044' '\046'-'\060' '\062'-'\090' '\096'-'\122' '\124''\127']
  | ['\194'-'\223']['\128'-'\191']
  | ['\224'-'\238']['\128'-'\191']['\128'-'\191']
  | '\239'['\128'-'\159']['\128'-'\191']
  | ['\240'-'\243']['\128'-'\191']['\128'-'\191']['\129'-'\191']
  | '\244'['\128'-'\143']['\128'-'\191']['\128'-'\191']

let space = [' ' '\t' '\r']
let newline = '\n'

let string = '"' ([^'"'] | "\\\"")* '"'

let verbatim_line = (''' ''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    (''' [^'\n' '\r' '''] [^'\n''\r']*) | 
                    ([^'\n' '\r' '''] [^'\n''\r']*) | 
		    (''' '''?)

let ident = ['a'-'z''A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*
let lident = ['a'-'z'] ['a'-'z''A'-'Z''0'-'9']*
let uident = ['A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*
let mathvar = ['a'-'z''A'-'Z']

let filename = ['a'-'z''A'-'Z''0'-'9''.''-']*

let sword = '(' | ')' | '[' | ']' | '"' | "=" | '-'

let word = utf8_char+

let line = sword | (word (space+ word)*)

rule comment = parse
    '*' ')' {  if pop_comment () then () else comment lexbuf }
  | '(' '*' {  push_comment (); comment lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unterminated_comment)) }
  | newline {  set_newline 1 (std_lexbuf lexbuf); comment lexbuf }
  | string {  comment lexbuf }
  | _ {  comment lexbuf }

and caml txps= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unexpected_end_of_comment)) }
  | ')' { if pop_caml () <= 0 then txps else caml txps lexbuf } 
  | '"' ([^'"'] | "\\\"")* '"' {
        String.iter (fun c->if c='\n' then set_newline 1 (std_lexbuf lexbuf))
          (Dyp.lexeme lexbuf);
        caml txps lexbuf
    }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; caml txps lexbuf } 
  | '(' { push_caml (); caml txps lexbuf } 
  | '<' '$' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      push_texprime_math () ; 
	      flush stdout; 
	      texprime_math lexbuf; 
	      caml ((TxpMath, start, l.lex_start_p.pos_cnum) :: txps) lexbuf } 
  | '<' '<' { let l = Dyp.std_lexbuf lexbuf in 
	      let start = l.lex_start_p.pos_cnum + 2 in 
	      push_texprime_text () ; 
	      flush stdout; 
	      texprime_text lexbuf; 
	      caml ((TxpText, start, l.lex_start_p.pos_cnum) :: txps) lexbuf } 
  | eof { [] }
  | newline { set_newline 1 (std_lexbuf lexbuf); caml txps lexbuf }
  | string { caml txps lexbuf }
  | _ { caml txps lexbuf }

and texprime_math= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unexpected_end_of_comment)) }
  | '$' '>' { if pop_texprime_math () then () else texprime_math lexbuf }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; texprime_math lexbuf } 
  | '<' '$' { push_texprime_math (); texprime_math lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unterminated_math)) }
  | newline { set_newline 1 (std_lexbuf lexbuf); texprime_math lexbuf }
  | string { texprime_math lexbuf }
  | _ { texprime_math lexbuf }

and texprime_text= parse
    '*' ')' { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unexpected_end_of_comment)) }
  | '>''>' {  if pop_texprime_text () then () else texprime_text lexbuf }
  | '(' '*' { push_comment (); flush stdout; comment lexbuf; texprime_text lexbuf } 
  | '<''<' {  push_texprime_text (); texprime_text lexbuf } 
  | eof { raise (Syntax_Error(Dyp.lexeme_start_p lexbuf,PatolineLanguage.Unterminated_text)) }
  | newline {  set_newline 1 (std_lexbuf lexbuf); texprime_text lexbuf }
  | string {  texprime_text lexbuf }
  | _ {  texprime_text lexbuf }

main lexer =
  '\\' ['B''b'] "egin" -> BEGIN
  '\\' ['E''e'] "nd" -> END
  '\\' "Include" -> INCLUDE
  '\\' ident
    -> MACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '#' lident
    -> PPRE { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '#' uident
    -> TPRE { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '(' '*' -> { push_comment (); comment lexbuf }
  '(' -> CAML { let l = Dyp.std_lexbuf lexbuf in
		    let start = l.lex_start_p.pos_cnum + 1 in 
		    push_caml ();
		    let txps= caml [] lexbuf in
(*		    Printf.fprintf stderr "%d, %d\n" start l.lex_start_p.pos_cnum;*)
		    start, l.lex_start_p.pos_cnum, List.rev txps
		  }
  
%parser

parelt:
    in_par_macro<m> { m, false }
  | "$" math<m> "$" { [FC(false,m)], false }
  | line<w> { [TC w], false }
  | "\\{" { [TC "{"], false }
  | "\\\\"  { [TC "\\"], false }
  | "\\}"  { [TC "}"], false }
  | "~"  { [TC " "], false }
  | "\\_"  { [TC "_"],false }
  | "\\~"  { [TC "~"], false }
  | "_" paragraph_aux<p,false> "_" { [MC(`Single, "toggleItalic", [sParagraph(List.rev p)], [])], true }


paragraph_aux:
  | parelt<e, b>
    { e, b }
  | paragraph_aux<p, b> parelt<e, b'>   
    { 
      let c,l,m = layout_info dyp 1 2 in
      if p <> [] && (l > 1 (* or (l = 1 && m > 1) *)) then raise Giveup;
      (e@(if c > 0 then GC::p else p)), b or b' }

paragraph: 
   paragraph_aux<p, _> { List.rev p }

oparagraph: {[]} | paragraph<p> {p}

allparagraph:
   paragraph<p> eof { p }

word_macro: MACRO<name>
  { let test =
      (List.mem_assoc name dyp.local_data.word_macros ||
      let c = Char.code name.[0] in
      (Char.code 'a' <= c && c <= Char.code 'z')) &&
     not (List.mem_assoc name dyp.local_data.par_macros)
    in
    if not test then raise Giveup;
    name }    

par_macro: MACRO<name>
  { let test =
      (List.mem_assoc name dyp.local_data.par_macros  ||
      let c = Char.code name.[0] in
      (Char.code 'A' <= c && c <= Char.code 'Z'))
     &&    
      not (List.mem_assoc name dyp.local_data.word_macros)
    in
    if not test then raise Giveup;
    name }    
      
args:
    /* empty */
     { (fun (ld:local_data) gr  -> []) } 
  | "()"
    { (fun (ld:local_data) gr  -> []) } 
  | args<a> - "{" oparagraph<p> "}" 
    { (fun ld gr -> sParagraph (p)::a ld gr) } 
  | args<a> - CAML<s,e,txps>
    { if e - s < 1 then raise Giveup; 
      (fun ld gr -> Caml(ld,gr,s,e,txps) :: a ld gr) } 

neargs:
  | "()"
    { (fun (ld:local_data) gr  -> []) }
  | "{" oparagraph<p> "}" 
    { (fun (ld:local_data) gr -> [sParagraph (p)]) }
  | CAML<s,e,txps>
    { if e - s < 1 then raise Giveup; 
      (fun ld gr -> [Caml(ld,gr,s,e,txps)]) }
  | neargs<a> - "{" oparagraph<p> "}" 
    { (fun ld gr -> sParagraph (p)::a ld gr) }
  | neargs<a> - CAML<s,e,txps>
    { if e - s < 1 then raise Giveup; 
      (fun ld gr -> Caml(ld,gr,s,e,txps) :: a ld gr) }

topmacro:
    BEGIN "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}" - args<a>
      { let ld, gr = get_local_data_and_grammar dyp in
        Macro(`Begin, name, List.rev (a ld gr), get_eminfo dyp name) }
  | END "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}"
      { Macro(`End, name, [], []) }
  | INCLUDE "{" (['a'-'z''A'-'Z''_']['a'-'z''A'-'Z''_''0'-'9']*)<name> "}"
      { Macro(`Include,name,[], []) }
  | par_macro<name> - args<a>
      { let ld, gr = get_local_data_and_grammar dyp in
        if List.mem name reserved then raise Giveup;
        Macro(`Module, name, List.rev (a ld gr), get_pminfo dyp name) }
  | TPRE<preproc> '{' preproc<text> '}'
      { try
            (*if Sys.file_exists (Printf.sprintf "%s.cmxs" preproc) then
              (Printf.sprintf "%s.cmxs" preproc)
            else
              (Printf.sprintf "%s%s.cmxs"(String.lowercase (String.sub preproc 0 1))
                 (String.sub preproc 1 (String.length preproc-1)));*)
            let f=StrMap.find preproc !macros in
            let t=String.concat "" text in
              Preproc (f t)
        with
            Not_found ->Printf.fprintf stderr "Error in toplevel macro \"%s\"\n" preproc;
	      flush stderr ; raise Not_found
      }
preproc:
      {[]}
  | '{' preproc<a> '}' preproc<b> { ("{"::a)@("}"::b) }
  | (utf8_char | space)*<a> preproc<b> {a::b}


in_par_macro:
  | word_macro<name> - neargs<a>
      { let ld, gr = get_local_data_and_grammar dyp in
        if List.mem name reserved then raise Giveup;
        [MC(`Single, name, List.rev (a ld gr), get_wminfo dyp name)] }  macro
  | word_macro<name>
      { if next_lexeme_paren (dyp.next_lexeme ()) then begin
	(* Printf.fprintf stderr "Giving up.\n" ; flush stderr ;  *) raise Giveup end
	else [MC(`Single, name, [], get_wminfo dyp name)] } args
  | PPRE<preproc> - CAML<s,e,txps>
      { let ld, gr = get_local_data_and_grammar dyp in
        [MC (`Preproc, preproc, [Caml (ld,gr,s,e,txps)], [])]
      }
  | PPRE<preproc> '{' preproc<text> '}'

      { try
          let f=StrMap.find preproc !par_macros in
          let t=String.concat "" text in
            f t
        with
            Not_found ->Printf.fprintf stderr "Error in macro \"%s\"\n" preproc;
	      flush stderr ; raise Not_found
      }

leftind:
  | math(<=atom)<m1> - "^^" - math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = Some m1; down_right = None; down_left = Some m2 } }
  | math(<=atom)<m1> - "__" - math(<=atom)<m2> - "^^" 
      { { up_right = None; up_left = Some m2; down_right = None; down_left = Some m1 } }
  | math(<=atom)<m1> - "^^"
      { { up_right = None; up_left = Some m1; down_right = None; down_left = None } }
  | math(<=atom)<m2> - "__" 
      { { up_right = None; up_left = None; down_right = None; down_left = Some m2 } }

rightind:
  | "^" - math(<=atom)<m1> - "_" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m1; down_right = Some m2 } }
  | "_" - math(<=atom)<m1> - "^" - math(<=atom)<m2>
      { fun i -> { i with up_right = Some m2; down_right = Some m1 } }
  | "^" - math(<=atom)<m1>
      { fun i -> { i with up_right = Some m1 } }
  | "_" - math(<=atom)<m1>
      { fun i -> { i with down_right = Some m1 } }

promath:
    math(<=prod)<m> { m }

allmath:
   math<m> eof { m }

mathargs:
  /* empty */
    { (fun (ld:local_data) gr  -> []) } atom
  | "()"
    { (fun (ld:local_data) gr  -> []) } args
  | mathargs<a> - "{" math<m> "}"
    { (fun ld gr -> m::a ld gr) }  args
  | mathargs<a> - CAML<s,e,txps>
    { if e - s < 1 then raise Giveup;
      (fun ld gr -> MathCaml(ld,gr,s,e,txps) :: a ld gr) }

var_or_symbol:
   (mathvar)<name>
      { Var(name) }
  | symbol<name>
      { Symbol(name) }

left:
   "\\left" right<d> { d }
  |"\\left." { "[]" }

right:
   "\\right" left<d> { d }
   |"\\right." { "[]" }
 
math:
   (mathvar)<name>
      { Var(name) } atom
  | (['a'-'z''A'-'Z']['a'-'z''A'-'Z']+)<name> 
      { Fun(name) } atom
  | (['0'-'9']+('.'['0'-'9']+)?) <num> 
      {Num num } atom
  | left<op> math<a> right<cl>
      { Delim(op,a,cl) } atom

  | "{" math<a> "}"
      { a } atom

  | "{" addition_like<op> "}"
      { Symbol op } atom
  | "{" product_like<op> "}"
      { Symbol op } atom
  | "{" prefix<op> "}"
      { Symbol op } atom
  | "{" postfix<op> "}"
      { Symbol op } atom
  | "{" accent<op> "}"
      { Symbol op } atom
  | "{" arrow<op> "}"
      { Symbol op } atom
  | "{" connector<op> "}"
      { Symbol op } atom
  | "{" relation<op> "}"
      { Symbol op } atom

  | leftind<i> - math(<ind)<m> [- rightind]?<fi>
      { let fi = match fi with None -> (fun x -> x) | Some f -> f in
        Indices(fi i, m) } ind
  | math(<ind)<m> - rightind<fi>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
        Indices(fi d, m) } ind

  | quantifier<m> math(<operator)<v> [ relation<r> math(<operator)<e> {r, e} ]?<c> [punctuation]?<p> math(<=operator)<b>
      { match c, p with
        | None, None -> Binary(1,Prefix(3,m,false,v),false,SimpleSym "",false,b)
        | None, Some p -> Binary(0,Prefix(3,m,false,v),true,p,false,b)
        | Some(r,e), None -> Binary(1,Prefix(3,m,false,Binary(3,v,false,r,false,e)),
	                         false,SimpleSym "",false,b)
        | Some(r,e), Some p -> Binary(0,Prefix(3,m,false,Binary(3,v,false,r,false,e)),
	                         true,p,false,b)
      } operator

  | leftind<i> - operator<m> [- rightind]?<fi> math(<=operator)<b>
      { let fi = match fi with None -> (fun x -> x) | Some f -> f in
        Indices(fi i, Operator(m,b)) } operator
  | operator<m> - rightind<fi> math(<=operator)<b>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
          Indices(fi d, Operator (m,b)) } operator
  | operator<m> math(<=operator)<b>
      { Operator (m,b) } operator

  | limits_operator<m> - rightind<fi> math(<=operator)<b>
      { let d =  { up_right = None; up_left = None; down_right = None; down_left = None } in
          Indices(fi d, Limits_operator (m,b)) } operator
  | limits_operator<m> math(<=operator)<b>
      { Limits_operator (m,b) } operator

  | math(<=fun)<a> - math(<fun)<b>
      { Apply(a, b) } fun
  | math(<=sum)<a> addition_like<op> math(<sum)<b>
      { Binary(2, a, false, op, false, b) } sum
  | "\\" - (ident)<macro> - mathargs<args> 
    { let ld, gr = get_local_data_and_grammar dyp in
      let macro' = "\\"^macro in
      if StrSet.mem macro' dyp.local_data.other_symbols ||
         StrSet.mem macro' dyp.local_data.infixes
        then raise Giveup;
      if next_lexeme_paren (dyp.next_lexeme ()) then begin
        (* Printf.fprintf stderr "Giving up.\n" ; flush stderr ; *)   raise Giveup end
      else MathMacro (macro,List.rev (args ld gr)) } atom
  | prefix<op> math(<sum)<b> 
      { Prefix(3,op,false,b) } sum

  | math(<sum)<b> postfix<op>
      { Postfix(3,b,true,op) } sum
  | math(<=accent)<b> accent<op>
      { Postfix(3,b,true,op) } accent
  | math(<=prod)<a> product_like<op> math(<prod)<b> 
      { Binary(3, a, false, op, false, b) } prod
  | promath<a> math(<prod)<b>
      { if not (layout_space dyp 1 2) then raise Giveup; Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=prod)<a> "*" math(<prod)<b>
      { Binary(3, a, false, SimpleSym "", false, b) } prod
  | math(<=rel)<a> relation<op> math(<rel)<b> 
      { Binary(1, a, false, op, false, b) } rel
  | negation<op> math(<=neg)<b>  
      { Prefix(0,op,false,b) } neg
  | math(<=conj)<a> connector<op> math(<conj)<b> 
      { Binary(0, a, false, op, false, b) } conj
  | math(<=impl)<a> arrow<op> math(<impl)<b> 
      { Binary(0, a, false, op, false, b) } impl
  | math(<=punc)<a> punctuation<op> math(<punc)<b> 
      { Binary(2, a, true, op, false, b) } punc
  | symbol<name>
      { Symbol(name) } atom

symbol_name:
    ([^' ''{''}''\t''\n''\r''\\''#']+)<sym>

symbol_def:
    CAML<s,e,txps> {
      let ld, gr = get_local_data_and_grammar dyp in
      let buf = Buffer.create 80 in  
      !fprint_caml_buf ld gr buf s e txps;
      CamlSym(Buffer.contents buf)
    }
  | '{' symbol_name<sym> '}' { SimpleSym sym }

symbol_defs:
    CAML<s,e,txps> {
      let ld, gr = get_local_data_and_grammar dyp in
      let buf = Buffer.create 80 in  
      !fprint_caml_buf ld gr buf s e txps;
      Buffer.contents buf
    }

macro_option:
  "eat_left" { `Eat_left }
| "eat_right" { `Eat_right }
| "is_identity" { `Is_idt }
| "arg_" - (['0'-'9']+)<i> "=" ['a'-'z''A'-'Z''0'-'9''_']+<s> { `Arg_pat(int_of_string i, s) }
| "arg_" - (['0'-'9']+)<i> "no_parenthesis" { `Arg_nopar(int_of_string i) }

macro_options:
  | { [] }
  | macro_options<l> macro_option<o> { o::l }

atomelt:
  /* Section */
  | (("="|"-")">")<o> paragraph<title> text<content> (("="|"-")"<")<c>
    { let content = List.rev content in
      (match content with 
        Paragraph _:: _ -> if not (layout_parskip dyp 2 3) then raise Giveup
      | _ -> ());
      if o.[0] <> c.[0] then raise Giveup;
      [Struct(title, o.[0] = '=', Relative content)]
    }
  | (("=""="+)|("-""-"+))<o> paragraph<title>
      (("=""="+)|("-""-"+))<c>
    { let level = String.length o in
      if level >= 10 then raise Giveup;
      if c <> o then raise Giveup;
      [Struct(title,  o.[0] = '=', Absolute (level - 1))] }
  | "\"\"\"" [ (ident) ]?<lang> "\n"
    [ - (verbatim_line)<l> - "\n" {l}]*<ls>
    "\"\"\""
    { [Verbatim(lang, ls)] }
  /* Code Caml */
  | "\\Caml" CAML<s,e,txps>
    { let ld, gr = get_local_data_and_grammar dyp in
      [Caml(ld,gr,s,e,txps)] }
  /* Top level macros \Begin or \Ident */
  | topmacro<m>
    { [m] }
  /* Symbol extension */
  | "\\Add_relation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "relation" (fun x -> Obj_relation x) names value }
  | "\\Add_addition_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
      "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "addition_like" (fun x -> Obj_addition_like x) names value }
  | "\\Add_product_like" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "product_like" (fun x -> Obj_product_like x) names value }
  | "\\Add_connector" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "connector" (fun x -> Obj_connector x) names value }
  | "\\Add_negation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "negation" (fun x -> Obj_negation x) names value }
  | "\\Add_arrow" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "arrow" (fun x -> Obj_arrow x) names value }
  | "\\Add_punctuation" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "punctuation" (fun x -> Obj_punctuation x) names value }
  | "\\Add_prefix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "prefix" (fun x -> Obj_prefix x) names value }
  | "\\Add_quantifier" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "quantifier" (fun x -> Obj_quantifier x) names value }
  | "\\Add_postfix" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "postfix" (fun x -> Obj_postfix x) names value }
  | "\\Add_accent" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "accent" (fun x -> Obj_accent x) names value }
  | "\\Add_operator" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "operator" (fun x -> Obj_operator x) names value }
  | "\\Add_limits_operator" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "limits_operator" (fun x -> Obj_limits_operator x) names value }
  | "\\Add_symbol" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_def<value>
    @{ add_symbol_rule dyp.local_data "symbol" (fun x -> Obj_symbol x) names value }
  | "\\Add_left" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "left" (fun x -> Obj_left x) names value }
  | "\\Add_left" "{" "\\{"<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "left" (fun x -> Obj_left x) [names] value }
  | "\\Add_right" "{" [ ['\\' -]?<s> symbol_name<w> { if s = None then w else "\\"^w } ]*<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "right" (fun x -> Obj_right x) names value }
  | "\\Add_right" "{" "\\}"<names> 
    "}" symbol_defs<value>
    @{ add_multi_symbol_rule dyp.local_data "right" (fun x -> Obj_right x) [names] value }
  | "\\Add_combining" "{" (utf8_char)<symbol> "}" "{" MACRO<m> "}"
    @{ add_combining_symbol dyp.local_data symbol m }
  | "\\Configure_word_macro" "{" '\\' - symbol_name<w> "}" "{" macro_options<o> "}"
    @{ [Ignore], 
       [Local_data { dyp.local_data with word_macros = (w, o)::dyp.local_data.word_macros }]
     }
  | "\\Configure_paragraph_macro" "{" '\\' - symbol_name<w> "}" "{" macro_options<o> "}"
    @{ [Ignore], 
       [Local_data { dyp.local_data with par_macros = (w, o)::dyp.local_data.par_macros }]
     }
  | "\\Configure_environment" "{" symbol_name<w> "}" "{" macro_options<o> "}"
    @{ [Ignore], 
       [Local_data { dyp.local_data with env_macros = (w, o)::dyp.local_data.env_macros }]
     }
  | "\\Save_Grammar"
    { let oc = open_out_bin (!out_grammar_name^gram_ext) in
      let ld = { dyp.local_data with verbose = false } in
      Marshal.to_channel oc (ld, dyp.parser_pilot.pp_dev) [ Marshal.Closures ];
      close_out oc;
      [Ignore]
    } 
  | "$$" math<m> "$$" { [Math(m)] }
  | "\\Verbose_Changes" 
    @{ [Ignore], [Local_data { dyp.local_data with verbose = true }] }

atomeltp:
    atomelt<e> @{ e, [ Keep_grammar; Local_data dyp.last_local_data ] }
  | paragraph<p> @{ 
      let _,_,m = layout_info dyp 1 1 in
      let options = { default_paragraph_options with center_paragraph = m >= 4 } in
      [Paragraph(options, p)], [ Keep_grammar; Local_data dyp.last_local_data ] }

title:
  ("=========="('='*))
    paragraph<title>
     [("----------"('-'*)) paragraph<author>
      [("----------"('-'*)) paragraph]?<institute> {author, institute} ]?<at>
  ("=========="('='*))
  { title,at }

text: { [] } | ntext<t> @{ t, [ Keep_grammar; Local_data dyp.last_local_data ]}

ntext:
  | atomeltp<p> 
   @{ p, [ Keep_grammar; Local_data dyp.last_local_data ] }
  | ntext<t> atomeltp<p>
   @{ 
      (match t, p with 
        (Paragraph _::_), (Paragraph _::_) ->
	  if not (layout_parskip dyp 1 2) then raise Giveup
       | _ -> ()); 
      (p@t), [ Keep_grammar; Local_data dyp.last_local_data ]}

grammar_aux:
    { Some "DefaultGrammar" }
  | "\\Use_Grammar{" filename<name> "}"
    { (* Printf.fprintf stderr "Some\n"; *) Some name }
  | "\\No_Grammar"
    { (* Printf.fprintf stderr "None\n"; *) None }

grammar: grammar_aux<g>
    @{(match g, !deps_only with
           Some filename,Some f->(
             let i=open_out_gen [Open_append] 0644 f in
               Printf.fprintf i "%s\n" (filename^gram_ext);
               close_out i;
           )
         | _,Some _->()
         | _->()
      );

      let action = match g with
           (* Patch temporaire : on ne charge pas de grammaire s'il n'y a pas de chemin,
              pour éviter les "code mismatch". L'option --no-grammar de TeX' contrôle ça *)
        Some filename when !PatolineConfig.grammarsdir <> []-> (
	  try
	    let grammar_name =
              let name=try findGrammar (filename ^ gram_ext) with _->"" in
              let orig=try findGrammar (filename^".txp") with _->"" in
                if orig<>"" &&
                  (name="" ||
                      (Unix.stat orig).Unix.st_mtime > (Unix.stat name).Unix.st_mtime ||
                      (Unix.stat Sys.executable_name).Unix.st_mtime > (Unix.stat name).Unix.st_mtime
                  ) then (
                    let path=String.concat ""
                      (List.map (Printf.sprintf " -I %s ") !PatolineConfig.grammarsdir)
                    in
                    let com=(Printf.sprintf "%s --noamble --ml %s %s" (Sys.argv.(0)) path orig) in
                      Printf.printf "%s\n" com; flush stdout;
                    let _=Sys.command com in
                      findGrammar (filename ^ gram_ext)
                  )
                else
                  name
            in
	    let ic = open_in grammar_name in
	    let local_data, grammar = input_value ic in
	      close_in ic;
              used_grammars:=filename::(!used_grammars);
	      (* Printf.fprintf stderr "Grammar: %s.\n" grammar_name ; *)
	      [ Local_data local_data; Parser grammar ]
          with
            | e ->(Printf.fprintf stderr "No Grammar Loaded (%s). Pwd = %S\n" (filename^gram_ext) (Sys.getcwd ()); [])
        )
      | _-> []
       in
       (), action
    }

main:
  | grammar [title]?<p> text<t> eof
    { (p, List.rev t) }
