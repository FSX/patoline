
(* test *)

(* 
   A compiler avec 
   texprime --format Format/Article --caml Diag.cmx Dcats.txp
*)

(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)


{{
open Typography.Document
open Typography.Parameters
open Typography.Fonts.FTypes
open Typography.Util
open Typography.Fonts
open Typography.Constants
open Typography.Binary
open Diag

module DFormat = Format.Default

let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (Binary.StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let emph = toggleItalic
let cat = <$C$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let indiv = <$I$>
  let mamacro () = << du texte >>

module Env_definition=DFormat.Make_theorem
    (struct
       let refType="definition"
       let counter="definition"
       let counterLevel=2
       let display num=alternative Bold [T ("Definition "^num^"."); B (fun env->env.stdGlue)]
     end)
module Env_theorem=DFormat.Make_theorem
    (struct
       let refType="theorem"
       let counter="theorem"
       let counterLevel=2
       let display num=alternative Bold [T ("Theorem "^num^"."); B (fun env->env.stdGlue)]
     end)
module Env_abstract = DFormat.Env_abstract

}}


\Begin{abstract}
We generalise the construction in previous work of a playground for CCS. New instances are $\pi$ and $\lambda$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);;

 let _ = table_of_contents D.structure (top (List.hd !D.structure)) 1 ;;
 
 let _ = go_up D.structure (* 2 *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}
In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $C/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat$. 


{{
let fig env=
  let state = [] in
  let params = NodeShape.default in  
  let a, state = Node.make_draw env state { Node.default with
    Node.contents_spec = <<A>>;
    Node.shape = (NodeShape.circle ~parameters:params ~inner_sep:4. ()) }
  in
  let b, state = Node.make_draw env state { Node.default with
    Node.at = (30.,70.) ;
    Node.contents_spec = [T "J"] ;
    Node.shape = (NodeShape.rectangle ~parameters:{ params with (* lineWidth=3. ;  *)
      lineJoin=Round_join} ~inner_sep:2. ()) }
  in
  let c, state = Node.make_draw env state { Node.default with
    Node.at = (90.,30.) ;
    Node.contents_spec = (alternative Bold [T "Ailllaillaille!"]) ;
    Node.shape = (NodeShape.flower ~parameters:params ~amplitude:3. ()) }
  in
  let d, state = Node.make_draw env state { 
    Node.at = b.Node.make_anchor Anchor.West ;
    Node.contents_spec =  <<$a$>> ;
    Node.anchor = Anchor.East ;
    Node.shape = (NodeShape.rectangle 
		    ~parameters:{ params with lineWidth=0.5 ; lineJoin=Round_join} 
		    ~inner_sep:1. ()) }
  in
  let e, state = Node.make_draw env state { Node.default with
    Node.at = c.Node.make_anchor Anchor.North ;
    Node.anchor = Anchor.South ;
    Node.contents_spec = [T "X"] ;
    Node.shape = (NodeShape.rectangle ~parameters:params ~inner_sep:4. ()) }
  in
  drawing ~offset:(-10.) (List.rev state)
 let _ = figure D.structure ~name:"figure de Tom" fig
}}



=<


=> The $\lambda$-calculus

=<
