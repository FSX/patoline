
(* test *)

(* 
   A compiler avec 
   texprime --format Format/Article --caml Diagram.cmxa Dcats.txp
*)

(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)


{{
open Diagram.Diagram
open Diagram

open Typography.Document
open Typography.Parameters
open Typography.Fonts.FTypes
open Typography.Util
open Typography.Fonts
open Typography.Constants
open Typography.Binary

module DFormat = Format.Default
open Format

let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (Binary.StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let emph = toggleItalic
let cat = <$C$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let indiv = <$I$>
  let mamacro () = << du texte >>


}}


\Begin{abstract}
We generalise the construction in previous work of a playground for CCS. New instances are $\pi$ and $\lambda$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);;

 let _ = table_of_contents D.structure (top (List.hd !D.structure)) 1 ;;
 
 let _ = go_up D.structure (* 2 *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}
In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $C/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat$. 


{{

  let fig env=
    let i, statei = node env [ `Shape `Rectangle ; ] <<$I$>> in
    let j, statej = node env [ `Shape `Rectangle ; `At (20.,20.) ] <<$J$>>
    in
    drawing ~offset:(-10.) (List.rev (statei @ statej))
 let _ = figure D.structure ~name:"figure de Tom" fig
}}



=<


=> The $\lambda$-calculus

=<
