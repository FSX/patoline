
(* test *)

(* 
   A compiler avec 
texprime --caml "-I /usr/local/lib/ocaml Diagrams.cmxa" --format Format/Article Dcats.txp
*)

(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)


{{
open Diagrams.Diagram
open Diagrams
open Typography.Complete
open Typography.Fonts.FTypes
(* open Typography.Constants *)
(* open Typography.Binary *)

module DFormat = Format.Default
open Format

let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let emph = toggleItalic
let cat = <$C$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let indiv = <$I$>
  let mamacro () = << du texte >>
open Article
}}


\Begin{abstract}
We generalise the construction in previous work \cite{{["Hirschowitz"]}} of a playground for CCS. New instances are $\pi$ and $\lambda$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

 (*  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);; *)

 (* let _ = Default.table_of_contents D.structure (top (List.hd !D.structure)) 1 ;; *)
 
 (* let _ = go_up D.structure (\* 2 *\) *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}
In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $C/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat$. 
      

\Begin{Diagram}
{{     let m,ms = matrix  [] [[ 
  ([],<<$J$>>) ; ([],<<$Y$>>) ];[
  ([],<<$K$>>) ; ];[
  ([],<<$I$>>) ; ([],<<$X$>>) ];[
        ]]
       
     let j = ms.(0).(0)
     let i = ms.(2).(0)
     let k = ms.(1).(0)
     let x = ms.(2).(1)
     let y = ms.(0).(1)

     open Diagrams

     let head info params = 
       let _ = begin 
	 Printf.fprintf stderr "Entering head: lineWidth = %f, true lineWidth = %f \n"
	   params.lineWidth info.tip_line_width ;
	 flush stderr
       end in
       if info.is_double then
	 let short = max (params.lineWidth /. 2.) 0.6 in
	 let thickness = params.lineWidth in
       let height = max (1.6 *. short) 0.8 in
       let width = max info.tip_line_width 1. in
       (short, thickness, height, width, 0.01)

       else

	let short = max (0.6 *. params.lineWidth) 0.2 in
	let thickness = max (0.7 *. params.lineWidth) 0.2 in
	let height = max (2. *. short) 0.8 in
	let width = max (1.3 *. info.tip_line_width) 1. in
	(short, thickness, height, width, 0.01)

     let l = edges [`To;`Draw] [
       ([`LineWidth 1.], i, [], x) ;
       ([`Double 0.5],j,[],y) ;
       ([],i,[],k) ;
       ([],j,[],k)
     ]

     (* let ik = List.nth l 2 *)


     (* let grad = Curve.eval (Curve.gradient ik.curve) 1.  *)
     (* let e = ik.anchor (`Temporal 1.) *)

     (* let _ = edge [`Head `To;`Draw] (coordinate e) [] (coordinate (Vector.(+) e grad)) *)

     (* let _ = node [`Circle;`Fill;`At (i.anchor `Base)] ([]) *)

 }}
\End{Diagram}




=<


=> The $\lambda$-calculus

=<

=> References

{{ thebibliography () }}

=<
