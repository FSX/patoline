
(* test *)

(* 
   A compiler avec 
texprime --caml "-I /usr/local/lib/ocaml Diagrams.cmxa" --format Format/Article Dcats.txp
*)

(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)


{{
open Diagrams.Diagram
open Diagrams
open Typography.Complete
open Typography.Fonts.FTypes
(* open Typography.Constants *)
(* open Typography.Binary *)

module DFormat = Format.Default
open Format

let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let emph = toggleItalic
let cat = <$C$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let indiv = <$I$>
  let mamacro () = << du texte >>
open Article
}}


\Begin{abstract}
We generalise the construction in previous work \cite{{["Hirschowitz"]}} of a playground for CCS. New instances are $\pi$ and $\lambda$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

 (*  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);; *)

 (* let _ = Default.table_of_contents D.structure (top (List.hd !D.structure)) 1 ;; *)
 
 (* let _ = go_up D.structure (\* 2 *\) *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}
In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $C/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat$. 



{{

 module MaFigure  (X : sig val env : user environment end) = struct
   module Lib = Fig (struct let str = D.structure let env = X.env end)
   include Lib
   
   let m,ms = matrix  [] [
      [ ([],<<$a$>>) ; ([],<<$b$>>) ; ([],<<$p$>>) ] ;
      [ ([],<<$c$>>) ]
   ] 
   
   (* let _ = node [`At (ms.(0).(0).anchor `Base);`Anchor `Center;`Circle;`Fill] ([]) *)
   (* let _ = node [`At (ms.(0).(1).anchor `Base);`Anchor `Center;`Circle;`Fill] ([]) *)

   let a = ms.(0).(0)

   let cb = edge [`Head `To ; `Draw;`Double 0.5 ; `BendLeft 20.] ms.(1).(0) [] ms.(0).(1)
   

 end

 module Rien = MakeFig (MaFigure) (D) (struct let name = "fig1" end)

}}

=<


=> The $\lambda$-calculus

=<

=> References

{{ thebibliography () }}

=<
