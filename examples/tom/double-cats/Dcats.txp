\Use_Grammar{notations}

====================================================
A format for playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)

\Caml(open Article ;;
open Diagrams.Diagram ;;
)
\Include{Preamble}

\Begin{abstract}

We generalise the construction in previous work \cite(["Hirschowitz"]) of a playground for CCS. New instances are $π$ and $λ$.

\End{abstract}


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv$ 
     of \emph{individuals}, which is discrete.

\End{definition}

In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $\cat/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ \indiv$.

  Let us start with a category $\cat$. 

  \Begin{definition}

  A \emph{rule shape} is a diagram of the shape

\Begin{equation}
    #diagram(

        let _ = rule_shape0 <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>

    )

\label("equation: rule shape") 

\End{equation}
  in $\cat$, such that $I$,$J$, and $K$ are interfaces.

  \End{definition}

Letting $\rs$ be the base category for this diagram, we may consider the set of isomorphism classes
of rule shapes, as objects of the functor category $[\rs,\cat]$. Call this set $\rulescat$. 
For each $ρ \in R_{\cat}$, the process of formally adding to $\cat$ an object representing  $ρ$ is implemented 
categorically
by taking a lax pushout of $ρ$ along the unique functor $\cat → 1$, as in 

    \Begin{center}

    #diagram(

      let _ = double_cell <<$\rs$>> <<$1$>> <<$\cat$>> <<$\cat[ρ]$.>> <<$a$>> <<$ρ$>> ([]) ([]) <<$x$>> ;;
	    
    )

    \End{center}

      We now want to do this at once for a whole part of $\rulescat$. Namely, let 
	  $\rulescatf$ be the set of isomorphism classes of rule shapes admitting a representative
of the form \eqref("equation: rule shape") with $X ∈ \indiv$. 
We call such (isomorphism classes of) rule shapes \emph{full}. 

Observe that lax pushouts are a particular case of category-enriched colimits \cite(["Kelly"]).
    To formally add objects for all full rule shapes to $\cat$, we  will take a more sophisticated lax 
      colimit, which requires to use the 
	  full definition. Our diagram shape, say $J$, is the free category on the graph




    \Begin{center}

    #diagram(

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$ρ$>>) ; ([], <<$1$>>) ];[
	([], <<$\cat$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$ρ'$>>) ; ([], <<$1$,>>) 
      ]]

	     let [rc;_;r'c;_] = edges [`To;`Draw] [
	       ([], ms.(0).(1), [], ms.(1).(0));
	       ([], ms.(0).(1), [], ms.(0).(2));
	       ([], ms.(2).(1), [], ms.(1).(0));
	       ([], ms.(2).(1), [], ms.(2).(2));
	     ]

	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    )

    \End{center}
with a row for each $ρ ∈ \rulescatf$.
Our weight $W : J^{op} → \categories$
is the diagram

    \Begin{center}

    #diagram(

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) ];[
	([], <<$1$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) 
      ]]

	     let [rc;unr;r'c;unr'] = edges [`To;`Draw] [
	       ([], ms.(1).(0), [], ms.(0).(1));
	       ([], ms.(0).(2), [], ms.(0).(1));
	       ([], ms.(1).(0), [], ms.(2).(1));
	       ([], ms.(2).(2), [], ms.(2).(1));
	     ]

	     let z1 = labelal rc <<$0$>>
	     let z2 = labelbl r'c <<$0$>>
	     let un1 = labela unr <<$1$>>
	     let un2 = labelbl unr' <<$1$>>
	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    )

    \End{center}
of categories and functors, where $2$ is the free category on the graph $0 → 1$.

  Let $\catplusf$ be any weighted colimit $F ⋆ W$. Concretely, for any full rule shape $ρ$, 
$\catplusf$ has an object, say just $[\rho]$, which is a colimit 
of $ρ$ \emph{qua} diagram, i.e., we have a colimiting cone

\Begin{center}

#diagram(
  let m,ms,es = rule_shape0  <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>
    
    let j = ms.(0).(0) 
    let i = ms.(2).(0) 
    let k = ms.(1).(0) 
    let x = ms.(2).(1) 
    let y = ms.(0).(1) 
    
    let rho = node [`At (ms.(1).(1).anchor `Center)] <<$[ρ]$>>

    let colimiting_cone = edges [`To;`Draw] [
      ([], k, [], rho) ;
      ([], x, [], rho) ;
      ([], y, [], rho) ;
    ]
)

\End{center}

These full rule shapes $[\rho]$ are analogous to `shapes of' syntactic constructs in calculi like CCS, 
$\pi$, or $\lambda$.
We will need \emph{branches} for such rules, which will be used to define views: these will be defined later.
What we need to specify is how such rules interact - and this is delicate.

The description of such an interaction will come in three parts: 

\Begin{itemize}
\item  the initial and final positions, first, say $X$ and $Y$, plus a cospan $Y → K ← X$ of positions (i.e., in $\cat$); 
\item  then a local description for each involved player;
\item  and finally a specification of how the local descriptions should fit together.

\End{itemize}

Local descriptions will be given as follows.
First, consider the pseudo-double category $\catD$ with horizontal category  $\cat$, vertical category given 
by the full subcategory of $\cospan{\widehat{\catplusf}}$ consisting of positions, and as double cells 
commuting diagrams of the shape

\Begin{center}

#diagram(

  let m, [|[|x;x'|];[|k;k'|];[|y;y'|]|] = matrix [] [[
    ([], <<$X$>>) ; ([], <<$X'$>>) ];[
    ([], <<$K$>>) ; ([], <<$K'$>>) ];[
    ([], <<$Y$>>) ; ([], <<$Y'$>>) 
  ]]

	let es = edges [`To;`Draw] [
	  ([],x,[],x') ;
	  ([],y,[],y') ;
	  ([],k,[],k') ;
	  ([],x,[],k) ;
	  ([],y,[],k) ;
	  ([],x',[],k') ;
	  ([],y',[],k') 
	]

	let _ = node [`At (y'.anchor `LineEast)] <<.>>

)

\End{center}

    In particular, the cospan $Y → K ← X$ is a vertical morphism $Y → X$ in $\catD$, say $M$.

Let furthermore, for each natural number $n ≥ 2$, $S_n$ be the free category on the graph with:

\Begin{itemize}

\item  $n + C^2_n$ objects, denoted by $1, n$ and then $(i,j) ∈ A$, 

\item morphisms $i ← (i,j) → j$ for all $i ≠ j$.

\End{itemize}

A family of local descriptions for an interaction is then given at once by a 
functor $shape : S_n → \catDH$, such that 
 for all $i ≠ j$, $shape$ maps both morphisms $i ← (i,j) → j$ to full rule shapes.

Finally, a specification of how local interactions should fit together is given by a natural transformation

\Begin{center}
#diagram(

  let m,ms = matrix [] [[
    ([], <<$S_n$>>) ; ([],[]); ([], <<$1$>>) ];[
    ([],[]) ; ([], <<$\catDH$,>>) ; ([],[])
  ]]

	let [u;l;r] = edges [`To;`Draw] [
	  ([], ms.(0).(0), [], ms.(0).(2)) ;
	  ([], ms.(0).(0), [], ms.(1).(1)) ;
	  ([], ms.(0).(2), [], ms.(1).(1)) 
	]

	let _ = labela u <<$!$>>
	  let _ = labelbl l <<$shape$>>
	  let _ = labelbr r <<$\name{M}$>>

	   let ealpha = edge [`Double 0.5 ; `BendRight 30.;`Shorten (0.1,0.1);`To;`Draw] 
	     (coordinate (l.anchor (`Temporal 0.3))) []
	     (coordinate (u.anchor (`Temporal 0.3)))

	let _ = labelbr ealpha <<$α$>>

)

\End{center}
   in other words, a cocone from $shape$ to $M$.

Any such cocone $α$ forms in particular a diagram in $\widehat{\catplusf}$, say 
$[α]$. Proceeding as we did to define $\catplusf$:

\Begin{definition}

Let $\catplusw$ be the result of formally 
adding to $\catplusf$ objects representing these diagrams. So we have embeddings
$\cat ↪ \catplusf ↪ \catplusw$ of categories.

\End{definition}



=<

=> The $λ$-calculus



=<

=> References

\Caml( let a = thebibliography () )


=<
