(* test *)


(* test *)

====================================================
A format for playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)

\Add_relation{\wcolim ⋆}{⋆}
\Add_relation{\neq ≠}{≠}

\Add_postfix{'}{'}
\Add_prefix{!}{!}
\Add_symbol{!}{!}
\Add_symbol{ ⌜ \ulcorner}{ ⌜ }
\Add_symbol{ ⌝ \urcorner}{ ⌝ }
\Add_left{ ( }{ ( }
\Add_right{ ) }{ ) }
\Add_left{ [ }{ [ }
\Add_right{ ] }{ ] }
\Add_left{ < }{ < }
\Add_right{ > }{ > }
\Add_left{ | }{ | }
\Add_right{ | }{ | }
\Add_left{\lceil ⌈}{⌈}
\Add_right{\rceil ⌉}{⌉}
\Add_left{\lfloor ⌊}{⌊}
\Add_right{\rfloor ⌋}{⌋}
\Add_left{\langle 〈}{〈}
\Add_right{\rangle 〉}{〉}

\Caml(
open Diagrams.Diagram
open Diagrams
open Typography.Complete
open Typography.Fonts.FTypes
(* open Typography.Constants *)
(* open Typography.Binary *)

module Euler = Article.Euler
module DFormat = Format.Default
open Format

type math_macro = user Typography.Maths.math list
type math_token = user Typography.Maths.math 

let id x = x
let emph = toggleItalic
let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let eqref name = <<\emph{(\caml(generalRef "equation" name))}>>
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let mathcal a=Euler.changeFont [Euler.Font `Cal] :: a
let fraktur a=Euler.changeFont [Euler.Font `Fraktur] :: a
let bf a=Euler.changeFont [Euler.Graisse `Gras] :: a
let bold a=alternative Bold a

let style s a = [Scoped ((fun env -> { env with mathStyle = s }), a)]
let scriptstyle x = style Mathematical.Script x
let displaystyle x = style Mathematical.Display x

let name x = <$\x$>
let cospan x = <$Cospan(\x)$>
let rules c = [Maths.Ordinary { (Maths.noad (Maths.glyphs "R")) with Maths.subscript_right = c } ]
let cat = <$\mathcal{C}$>
let catD = <$\mathcal{D}$> 
let catDh : math_macro = <$\catD_h$>
let catDH : math_macro = <$\catD_H$>	
let catplusb : math_macro = <$\cat_{b}$>
let catplusf : math_macro = <$\cat_{f}$>
let catplusw : math_macro = <$\cat_{w}$>
let categories : math_macro = <$Cat$> 
let indiv : math_macro = <$\mathcal{I}$>
let rs : math_macro =  <$\mathcal{R}$>
let rules c = <$R_{\c}$>
let rulesb c = <$R^{b}_{\c}$>
let rulesf c = <$R^{f}_{\c}$>
let rulescat : math_macro = rules cat
let rulescatb : math_macro = rulesb cat
let rulescatf : math_macro = rulesf cat
let op c = <$\c^{op}$>
let card c = <$|\c|$>
let players c = <$Pl(\c)$>



open Article


module Env_Diagram (Arg : sig val arg1 : string end)(Arg' : sig val env : user environment end) = struct
  include Env_Diagram (Arg) (Arg')

        let rule_shape x i k j y ix ik jk jy = 
	  let m,ms = matrix [] [[
            ([],j) ; ([],y) ];[ 
	    ([],k) ; ];[ 
	    ([],i) ; ([],x)  
	  ]] in 
	  let j = ms.(0).(0) in 
	  let i = ms.(2).(0) in 
	  let k = ms.(1).(0) in
          let x = ms.(2).(1) in 
	  let y = ms.(0).(1) in 
	  let l = edges [`To;`Draw] [ 
	    ([], i, [], x) ; 
	    ([],j,[],y) ; 
	    ([],i,[],k) ;
            ([],j,[],k) ] 
	  in m,ms,l

        let rule_shape0 x i k j y = rule_shape x i k j y ([]) ([])
        ([]) ([])

      let label e style pos contents = 
	node  ((`At (e.anchor (`Temporal pos))) :: style) 
	  (scriptstyle contents)

     let labela e contents = label e [`Anchor `South] 0.5 contents
     let labelb e contents = label e [`Anchor `North] 0.5 contents
     let labell e contents = label e [`Anchor `East] 0.5 contents
     let labelr e contents = label e [`Anchor `West] 0.5 contents
     let labelbr e contents = label e [`Anchor `NorthWest] 0.5 contents
     let labelbl e contents = label e [`Anchor `NorthEast] 0.5 contents
     let labelar e contents = label e [`Anchor `SouthWest] 0.5 contents
     let labelal e contents = label e [`Anchor `SouthEast] 0.5 contents
     let labelc e contents = label e [`Anchor `Main] 0.5 contents

     let double_cell  a b c d h u v l alpha = 
       let m, ms = matrix [] [[
	 ([], a) ; ([], b) ];[
	 ([], c) ; ([], d)
       ]]
       in
       let a = ms.(0).(0) in 
       let b = ms.(0).(1) in 
       let c = ms.(1).(0) in 
       let d = ms.(1).(1) in 
       let es = edges [`To;`Draw] 
	 [
	   ([], a, [], b) ;
	   ([], a, [], c) ;
	   ([], b, [], d) ;
	   ([], c, [], d) ;
	 ]
       in
       match es with
	 | [ ab;ac;bd;cd ] ->
	   let _ = labela ab h in
	   let _ = labell ac u in
	   let _ = labelr bd v in
	   let _ = labelb cd l in
	   let ealpha = edge [`Double 0.5 ; `BendRight 30.;`Shorten (0.1,0.1);`To;`Draw] 
	     (coordinate (ac.anchor (`Temporal 0.3))) []
	     (coordinate (ab.anchor (`Temporal 0.3)))
	   in
	   let _ = labelbr ealpha alpha in
	   ()
	 | _ -> assert false

     let dots s e = 
       let ed = edge [] s [] e in
       let _ = label ed [`Anchor `Main] 0.4 <<.>> in
       let _ = label ed [`Anchor `Main] 0.5 <<.>> in
       let _ = label ed [`Anchor `Main] 0.6 <<.>> in
       ()

end     



	let widehat maths = [Maths.Ordinary (Maths.noad (fun env style -> boxify_scoped env (<<#diagram(

	  let boxes = Maths.draw [{ env with mathStyle = style }] maths
	  let a,_ = node_boxified env 
	    [`Anchor `Pdf;`LineWidth 0.;`InnerSep 0.;`OuterSep 0.] 
	    (Box.draw_boxes boxes) ;;
          let _ = (stack := a :: !stack)
	  let h = 0.3 *. (Diagrams.ex env) 
	  let delta_h = (Maths.env_style env.mathsEnvironment style).Mathematical.default_rule_thickness 

	  let p1 = a.anchor `NorthWest 
	  let p2 = a.anchor `NorthEast 
	  let p_haut = Vector.(+) (Point.middle p1 p2) (0.,h) 
	  let p_bas = Vector.(+) (Point.middle p1 p2) (0.,(h +. delta_h))
	  let hat = path [`Fill;`LineWidth 0.03] p1 [[p_haut];[p2];[p_bas]] 
          let _ = (stack := hat :: !stack)	  

	)>>)))]



)



\Begin{abstract}

We generalise the construction in previous work \cite(["Hirschowitz"]) of a playground for CCS. New instances are $π$ and $λ$.

\End{abstract}


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat$ equipped with a subcategory $\indiv$ 
     of \emph{individuals}, which is discrete.

\End{definition}

In any individuality category $\cat$, an \emph{interface} is an object $X$ such that the slice
category $\cat/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ \indiv$.

  Let us start with a category $\cat$. 

  \Begin{definition}

  A \emph{rule shape} is a diagram of the shape

\Begin{equation}
    #diagram(

        let _ = rule_shape0 <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>

    )

\label("equation: rule shape") 

\End{equation}
  in $\cat$, such that $I$,$J$, and $K$ are interfaces.

  \End{definition}

Letting $\rs$ be the base category for this diagram, we may consider the set of isomorphism classes
of rule shapes, as objects of the functor category $[\rs,\cat]$. Call this set $\rulescat$. 
For each $ρ \in R_{\cat}$, the process of formally adding to $\cat$ an object representing  $ρ$ is implemented 
categorically
by taking a lax pushout of $ρ$ along the unique functor $\cat → 1$, as in 

    \Begin{center}

    #diagram(

      let _ = double_cell <<$\rs$>> <<$1$>> <<$\cat$>> <<$\cat[ρ]$.>> <<$a$>> <<$ρ$>> ([]) ([]) <<$x$>> ;;
	    
    )

    \End{center}

      We now want to do this at once for a whole part of $\rulescat$. Namely, let 
	  $\rulescatf$ be the set of isomorphism classes of rule shapes admitting a representative
of the form \eqref("equation: rule shape") with $X ∈ \indiv$. 
We call such (isomorphism classes of) rule shapes \emph{full}. 

    To formally add objects for all full rule shapes to $\cat$, we will take a more sophisticated lax 
      colimit, which requires to use the 
	  full definition. Our diagram shape, say $J$, is the free category on the graph




    \Begin{center}

    #diagram(

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$ρ$>>) ; ([], <<$1$>>) ];[
	([], <<$\cat$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$ρ'$>>) ; ([], <<$1$,>>) 
      ]]

	     let [rc;_;r'c;_] = edges [`To;`Draw] [
	       ([], ms.(0).(1), [], ms.(1).(0));
	       ([], ms.(0).(1), [], ms.(0).(2));
	       ([], ms.(2).(1), [], ms.(1).(0));
	       ([], ms.(2).(1), [], ms.(2).(2));
	     ]

	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    )

    \End{center}
with a row for each $ρ ∈ \rulescatf$.
Our weight $W : J^{op} → \categories$
is the diagram

    \Begin{center}

    #diagram(

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) ];[
	([], <<$1$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) 
      ]]

	     let [rc;unr;r'c;unr'] = edges [`To;`Draw] [
	       ([], ms.(1).(0), [], ms.(0).(1));
	       ([], ms.(0).(2), [], ms.(0).(1));
	       ([], ms.(1).(0), [], ms.(2).(1));
	       ([], ms.(2).(2), [], ms.(2).(1));
	     ]

	     let z1 = labelal rc <<$0$>>
	     let z2 = labelbl r'c <<$0$>>
	     let un1 = labela unr <<$1$>>
	     let un2 = labelbl unr' <<$1$>>
	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    )

    \End{center}
of categories and functors, where $2$ is the free category on the graph $0 → 1$.

  Let $\catplusf$ be any weighted colimit $F ⋆ W$. Concretely, for any full rule shape $ρ$, 
$\catplusf$ has an object, say just $[\rho]$, which is a colimit 
of $ρ$ \emph{qua} diagram, i.e., we have a colimiting cone

\Begin{center}

#diagram(
  let m,ms,es = rule_shape0  <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>
    
    let j = ms.(0).(0) 
    let i = ms.(2).(0) 
    let k = ms.(1).(0) 
    let x = ms.(2).(1) 
    let y = ms.(0).(1) 
    
    let rho = node [`At (ms.(1).(1).anchor `Center)] <<$[ρ]$>>

    let colimiting_cone = edges [`To;`Draw] [
      ([], k, [], rho) ;
      ([], x, [], rho) ;
      ([], y, [], rho) ;
    ]
)

\End{center}

These full rule shapes $[\rho]$ are analogous to `shapes of' syntactic constructs in calculi like CCS, 
$\pi$, or $\lambda$.
We will need \emph{branches} for such rules, which will be used to define views: these will be defined later.
What we need to specify is how such rules interact - and this is delicate.

The description of such an interaction will come in three parts: 

\Begin{itemize}
\item  the initial and final positions, first, say $X$ and $Y$, plus a cospan $Y → K ← X$ of positions (i.e., in $\cat$); 
\item  then a local description for each involved player;
\item  and finally a specification of how the local descriptions should fit together.

\End{itemize}

Local descriptions will be given as follows.
First, consider the pseudo-double category $\catD$ with horizontal category  $\cat$, vertical category given 
by the full subcategory of $\cospan{\widehat{\catplusf}}$ consisting of positions, and as double cells 
commuting diagrams of the shape

\Begin{center}

#diagram(

  let m, [|[|x;x'|];[|k;k'|];[|y;y'|]|] = matrix [] [[
    ([], <<$X$>>) ; ([], <<$X'$>>) ];[
    ([], <<$K$>>) ; ([], <<$K'$>>) ];[
    ([], <<$Y$>>) ; ([], <<$Y'$>>) 
  ]]

	let es = edges [`To;`Draw] [
	  ([],x,[],x') ;
	  ([],y,[],y') ;
	  ([],k,[],k') ;
	  ([],x,[],k) ;
	  ([],y,[],k) ;
	  ([],x',[],k') ;
	  ([],y',[],k') 
	]

	let _ = node [`At (y'.anchor `LineEast)] <<.>>

)

\End{center}

    In particular, the cospan $Y → K ← X$ is a vertical morphism $Y → X$ in $\catD$, say $M$.

Let furthermore, for each natural number $n ≥ 2$, $S_n$ be the free category on the graph with:

\Begin{itemize}

\item  $n + C^2_n$ objects, denoted by $1, n$ and then $(i,j) ∈ A$, 

\item morphisms $i ← (i,j) → j$ for all $i ≠ j$.

\End{itemize}

A family of local descriptions for an interaction is then given at once by a 
functor $shape : S_n → \catDH$, such that 
 for all $i ≠ j$, $shape$ maps both morphisms $i ← (i,j) → j$ to full rule shapes.

Finally, a specification of how local interactions should fit together is given by a natural transformation

\Begin{center}
#diagram(

  let m,ms = matrix [] [[
    ([], <<$S_n$>>) ; ([],[]); ([], <<$1$>>) ];[
    ([],[]) ; ([], <<$\catDH$,>>) ; ([],[])
  ]]

	let [u;l;r] = edges [`To;`Draw] [
	  ([], ms.(0).(0), [], ms.(0).(2)) ;
	  ([], ms.(0).(0), [], ms.(1).(1)) ;
	  ([], ms.(0).(2), [], ms.(1).(1)) 
	]

	let _ = labela u <<$!$>>
	  let _ = labelbl l <<$shape$>>
	  let _ = labelbr r <<$\name{M}$>>

	   let ealpha = edge [`Double 0.5 ; `BendRight 30.;`Shorten (0.1,0.1);`To;`Draw] 
	     (coordinate (l.anchor (`Temporal 0.3))) []
	     (coordinate (u.anchor (`Temporal 0.3)))

	let _ = labelbr ealpha <<$α$>>

)

\End{center}
   in other words, a cocone from $shape$ to $M$.

Any such cocone $α$ forms in particular a diagram in $\widehat{\catplusf}$, say 
$[α]$. Proceeding as we did to define $\catplusf$:

\Begin{definition}

Let $\catplusw$ be the result of formally 
adding to $\catplusf$ objects representing these diagrams. So we have embeddings
$\cat ↪ \catplusf ↪ \catplusw$ of categories.

\End{definition}

=<

=> The $λ$-calculus



=<

=> References

\Caml( let a = thebibliography () )


=<
