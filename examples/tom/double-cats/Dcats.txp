(* test *)


(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)

\Add_relation{\wcolim ⋆}{⋆}

\Add_left{ ( }{ ( }
\Add_right{ ) }{ ) }
\Add_left{ [ }{ [ }
\Add_right{ ] }{ ] }
\Add_left{ < }{ < }
\Add_right{ > }{ > }
\Add_left{ | }{ | }
\Add_right{ | }{ | }
\Add_left{\lceil ⌈}{⌈}
\Add_right{\rceil ⌉}{⌉}
\Add_left{\lfloor ⌊}{⌊}
\Add_right{\rfloor ⌋}{⌋}
\Add_left{\langle 〈}{〈}
\Add_right{\rangle 〉}{〉}

{{

open Diagrams.Diagram
open Diagrams
open Typography.Complete
open Typography.Fonts.FTypes
(* open Typography.Constants *)
(* open Typography.Binary *)

module Euler = Article.Euler
module DFormat = Format.Default
open Format

let id x = x
let emph = toggleItalic
let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let eqref name = <<\emph{(\id{{generalRef "equation" name}})}>>
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let displaystyle=[Maths.Style Mathematical.Display]
let scriptstyle s _=Maths.Style Mathematical.Script::s
let mathcal a=Euler.changeFont [Euler.Font `Cal] :: a
let fraktur a=Euler.changeFont [Euler.Font `Fraktur] :: a
let bf a=Euler.changeFont [Euler.Graisse `Gras] :: a
let bold a=alternative Bold a

let math arg = [B (fun env0 -> List.map (fun b -> Box.resize env0.size b) (* math <$lala$> *)
  (let style = Mathematical.Text and _env = (Maths.env_style Maths.default Mathematical.Text) in 
   Maths.draw_maths env0 style ((arg ))))]

let script_style = Env (fun env -> { env with size = env.size *. 2. /. 3. }) 

let rules c = [Maths.Ordinary { (Maths.noad (Maths.glyphs "R")) with Maths.subscript_right = c } ]
let cat = <$\mathcal{C}$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let catplusb = <$\mathcal{C}^{b}$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let categories = <$Cat$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let indiv = <$\mathcal{I}$>
let rs =  <$\mathcal{R}$>
let rules c = <$R_{\c{}}$>
let rulesb c = <$R^{b}_{\c{}}$>
let rulescat = rules <$\cat{}$>
let rulescatb = rulesb <$\cat{}$>
let op c = <$\c{}^{op}$>
let card c = <$|\c{}|$>
let players c = <$Pl(\c{})$>


open Article


module Env_Diagram (Arg : sig val arg1 : string end)(Arg' : sig val env : user environment end) = struct
  include Env_Diagram (Arg) (Arg')

        let rule_shape x i k j y ix ik jk jy = 
	  let m,ms = matrix [] [[
            ([],j) ; ([],y) ];[ 
	    ([],k) ; ];[ 
	    ([],i) ; ([],x)  
	  ]] in 
	  let j = ms.(0).(0) in 
	  let i = ms.(2).(0) in 
	  let k = ms.(1).(0) in
          let x = ms.(2).(1) in 
	  let y = ms.(0).(1) in 
	  let l = edges [`To;`Draw] [ 
	    ([], i, [], x) ; 
	    ([],j,[],y) ; 
	    ([],i,[],k) ;
            ([],j,[],k) ] 
	  in m,ms,l

        let rule_shape0 x i k j y = rule_shape x i k j y ([]) ([])
        ([]) ([])

      let label e style pos contents = 
	node  ((`At (e.anchor (`Temporal pos))) :: style) (script_style :: contents)

     let labela e contents = label e [`Anchor `South] 0.5 contents
     let labelb e contents = label e [`Anchor `North] 0.5 contents
     let labell e contents = label e [`Anchor `East] 0.5 contents
     let labelr e contents = label e [`Anchor `West] 0.5 contents
     let labelbr e contents = label e [`Anchor `NorthWest] 0.5 contents
     let labelbl e contents = label e [`Anchor `NorthEast] 0.5 contents
     let labelar e contents = label e [`Anchor `SouthWest] 0.5 contents
     let labelal e contents = label e [`Anchor `SouthEast] 0.5 contents
     let labelc e contents = label e [`Anchor `Main] 0.5 contents

     let double_cell  a b c d h u v l alpha = 
       let m, ms = matrix [] [[
	 ([], a) ; ([], b) ];[
	 ([], c) ; ([], d)
       ]]
       in
       let a = ms.(0).(0) in 
       let b = ms.(0).(1) in 
       let c = ms.(1).(0) in 
       let d = ms.(1).(1) in 
       let es = edges [`To;`Draw] 
	 [
	   ([], a, [], b) ;
	   ([], a, [], c) ;
	   ([], b, [], d) ;
	   ([], c, [], d) ;
	 ]
       in
       match es with
	 | [ ab;ac;bd;cd ] ->
	   let _ = labela ab h in
	   let _ = labell ac u in
	   let _ = labelr bd v in
	   let _ = labelb cd l in
	   let ealpha = edge [`Double 0.5 ; `BendRight 30.;`Shorten (0.1,0.1);`To;`Draw] 
	     (coordinate (ac.anchor (`Temporal 0.3))) []
	     (coordinate (ab.anchor (`Temporal 0.3)))
	   in
	   let _ = labelbr ealpha alpha in
	   ()
	 | _ -> assert false

     let dots s e = 
       let ed = edge [] s [] e in
       let _ = label ed [`Anchor `Main;`Rotate] 0.4 <<.>> in
       let _ = label ed [`Anchor `Main;`Rotate] 0.5 <<.>> in
       let _ = label ed [`Anchor `Main;`Rotate] 0.6 <<.>> in
       ()

end     

}}


\Begin{abstract}

We generalise the construction in previous work \cite{{["Hirschowitz"]}} of a playground for CCS. New instances are $π$ and $λ$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

 (*  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);; *)

 (* let _ = Default.table_of_contents D.structure (top (List.hd !D.structure)) 1 ;; *)
 
 (* let _ = go_up D.structure (\* 2 *\) *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat{}$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}

In any individuality category $\cat{}$, an \emph{interface} is an object $X$ such that the slice
category $\cat{}/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat{}$. 
      

  \Begin{definition}

  A \emph{rule shape} is a diagram of the shape

\Begin{equation}
    #diagram{{

        let _ = rule_shape0 <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>

      }}

\label{{"equation: rule shape"}}

\End{equation}
  in $\cat{}$, such that $I$,$J$, and $K$ are interfaces.

  \End{definition}

Letting $\rs{}$ be the base category for this diagram, we may consider the set of isomorphism classes
of rule shapes, as objects of the functor category $[\rs{},\cat{}]$. Call this set $\rulescat{}$. 
For each $ρ \in R_{ \cat{} }$, the process of adding a formal colimit to $ρ$ is implemented categorically
by taking a lax pushout of $ρ$ along the unique functor $\cat{} → 1$, as in 

    \Begin{center}

    #diagram{{

      let _ = double_cell <<$\rs{}$>> <<$1$>> <<$\cat{}$>> <<$\cat{}[ρ]$.>> <<$a$>> <<$ρ$>> ([]) ([]) <<$x$>> ;;
	    
    }}

    \End{center}

      We now want to do this at once for a whole part $\rulescat{}$. Namely, let 
	  $\rulescatb{}$ be the set of isomorphism classes of rule shapes admitting a representative
of the form \eqref{{"equation: rule shape"}} with $X ∈ \indiv{}$ and 
$\card{\players{Y}} ≤ 1$. We call such (isomorphism classes of) rule shapes \emph{basic}.

    To formally add colimits for such rule shapes to $\cat{}$, we will take a more sophisticated lax 
      colimit, which requires to use the 
	  full definition. Our diagram shape, say $J$, is the free category on the graph

    \Begin{center}

    #diagram{{

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$ρ$>>) ; ([], <<$1$>>) ];[
	([], <<$\cat{}$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$ρ_{1}$>>) ; ([], <<$1$,>>) 
      ]]

	     let [rc;_;r'c;_] = edges [`To;`Draw] [
	       ([], ms.(0).(1), [], ms.(1).(0));
	       ([], ms.(0).(1), [], ms.(0).(2));
	       ([], ms.(2).(1), [], ms.(1).(0));
	       ([], ms.(2).(1), [], ms.(2).(2));
	     ]

	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    }}

    \End{center}
with a row for each $ρ ∈ \rulescatb{}$.
Our weight $W : J^{op} → \categories{}$
is the diagram

    \Begin{center}

    #diagram{{

      let m,ms = matrix [`Centers (10.,20.)] [[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) ];[
	([], <<$1$>>); ([], []) ; ([], []) ];[
	([], []); ([], <<$2$>>) ; ([], <<$1$>>) 
      ]]

	     let [rc;unr;r'c;unr'] = edges [`To;`Draw] [
	       ([], ms.(1).(0), [], ms.(0).(1));
	       ([], ms.(0).(2), [], ms.(0).(1));
	       ([], ms.(1).(0), [], ms.(2).(1));
	       ([], ms.(2).(2), [], ms.(2).(1));
	     ]

	     let z1 = labelal rc <<$0$>>
	     let z2 = labelbl r'c <<$0$>>
	     let un1 = labela unr <<$1$>>
	     let un2 = labelbl unr' <<$1$>>
	     let _ = dots ms.(0).(1) ms.(2).(1)
	     let _ = dots ms.(0).(2) ms.(2).(2)
	    
    }}

    \End{center}
of categories and functors, where $2$ is the free category on the graph $0 → 1$.

  Let $\catplusb{}$ be any weighted colimit $F ⋆ W$. Concretely, for any basic rule shape $ρ$, 
$\catplusb{}$ has an object, say just $[\rho]$, which is a colimit 
of $ρ$ \emph{qua} diagram, i.e., we have a colimiting cone

\Begin{center}

#diagram{{
  let m,ms,es = rule_shape0  <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>
    
    let j = ms.(0).(0) 
    let i = ms.(2).(0) 
    let k = ms.(1).(0) 
    let x = ms.(2).(1) 
    let y = ms.(0).(1) 
    
    let rho = node [`At (ms.(1).(1).anchor `Center)] <<$[ρ]$>>

    let colimiting_cone = edges [`To;`Draw] [
      ([], k, [], rho) ;
      ([], x, [], rho) ;
      ([], y, [], rho) ;
    ]
}}

\End{center}



=<


=> The $\lambda$-calculus

=<

=> References

{{ let _ = thebibliography () ;; }}

=<
