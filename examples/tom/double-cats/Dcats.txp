
(* test *)

(* 
   A compiler avec 
texprime --caml "-I /usr/local/lib/ocaml Diagrams.cmxa Euler.cmxa" --format Format/Article Dcats.txp
*)

(* test *)

====================================================
Generating playgrounds

Tom Hirschowitz

CNRS, Université de Savoie
====================================================


(* test *)


{{

open Diagrams.Diagram
open Diagrams
open Typography.Complete
open Typography.Fonts.FTypes
(* open Typography.Constants *)
(* open Typography.Binary *)

module DFormat = Format.Default
open Format

let color x b = [Scoped ((fun env -> { env with fontColor = x }), b)]
let red=RGB {red=1.;green=0.;blue=0.}
let figRef ()= [B (fun env->
    let i=try match snd (StrMap.find "figures" env.counters) with []->0 | h::_->h with Not_found -> 0 in
     [User (FigureRef i)])]
let large text = [size 10. text]
let bb x = [Scoped ((fun env -> { env with fontAlternative = Bold }), x)]
let emph = toggleItalic
let displaystyle=[Maths.Style Mathematical.Display]
let scriptstyle s _=Maths.Style Mathematical.Script::s
let mathcal a=Euler.changeFont [Euler.Font `Cal] :: a
let fraktur a=Euler.changeFont [Euler.Font `Fraktur] :: a
let bf a=Euler.changeFont [Euler.Graisse `Gras] :: a
let bold a=alternative Bold a

let math arg = [B (fun env0 -> List.map (fun b -> Box.resize env0.size b) (* math <$lala$> *)
  (let style = Mathematical.Text and _env = (Maths.env_style Maths.default Mathematical.Text) in 
   Maths.draw_maths env0 style ((arg ))))]

let script_style = Env (fun env -> { env with size = env.size *. 2. /. 3. }) 

let rules c = [Maths.Ordinary { (Maths.noad (Maths.glyphs "R")) with Maths.subscript_right = c } ]
let cat = <$\mathcal{ {C} }$> (* [ Maths.Ordinary (Maths.noad (Maths.glyphs "C")) ] *)
let rulescat _ = <<$R_{ \cat{} }$>>
let indiv = <$\mathcal{ {I} }$>
let rs =  <$\mathcal{ {R} }$>
let rules c = <$R_{ \c{} }$>

open Article


module Env_Diagram (Arg : sig val arg1 : string end)(Arg' : sig val env : user environment end) = struct
  include Env_Diagram (Arg) (Arg')

        let rule_shape x i k j y ix ik jk jy = 
	  let m,ms = matrix [] [[
            ([],j) ; ([],y) ];[ 
	    ([],k) ; ];[ 
	    ([],i) ; ([],x) ];[ 
	  ]] in 
	  let j = ms.(0).(0) in 
	  let i = ms.(2).(0) in 
	  let k = ms.(1).(0) in
          let x = ms.(2).(1) in 
	  let y = ms.(0).(1) in 
	  let l = edges [`To;`Draw] [ 
	    ([], i, [], x) ; 
	    ([],j,[],y) ; 
	    ([],i,[],k) ;
            ([],j,[],k) ] 
	  in x

        let rule_shape0 x i k j y = rule_shape x i k j y ([]) ([])
        ([]) ([])

      let label e style pos contents = 
	node  ((`At (e.anchor (`Temporal pos))) :: style) (script_style :: contents)

     let labela e contents = label e [`Anchor `South] 0.5 contents
     let labelb e contents = label e [`Anchor `North] 0.5 contents
     let labell e contents = label e [`Anchor `East] 0.5 contents
     let labelr e contents = label e [`Anchor `West] 0.5 contents
     let labelbr e contents = label e [`Anchor `NorthWest] 0.5 contents
     let labelbl e contents = label e [`Anchor `NorthEast] 0.5 contents
     let labelar e contents = label e [`Anchor `SouthWest] 0.5 contents
     let labelal e contents = label e [`Anchor `SouthEast] 0.5 contents

     let double_cell  a b c d h u v l alpha = 
       let m, ms = matrix [] [[
	 ([], a) ; ([], b) ];[
	 ([], c) ; ([], d)
       ]]
       in
       let a = ms.(0).(0) in 
       let b = ms.(0).(1) in 
       let c = ms.(1).(0) in 
       let d = ms.(1).(1) in 
       let es = edges [`To;`Draw] 
	 [
	   ([], a, [], b) ;
	   ([], a, [], c) ;
	   ([], b, [], d) ;
	   ([], c, [], d) ;
	 ]
       in
       match es with
	 | [ ab;ac;bd;cd ] ->
	   let _ = labela ab h in
	   let _ = labell ac u in
	   let _ = labelr bd v in
	   let _ = labelb cd l in
	   let ealpha = edge [`Double 0.5 ; `BendRight 30.;`Shorten (0.1,0.1);`To;`Draw] 
	     (coordinate (ac.anchor (`Temporal 0.3))) []
	     (coordinate (ab.anchor (`Temporal 0.3)))
	   in
	   let _ = labelbr ealpha alpha in
	   ()
	 | _ -> assert false

end     

}}


\Begin{abstract}

We generalise the construction in previous work \cite{{["Hirschowitz"]}} of a playground for CCS. New instances are $π$ and $λ$.

\End{abstract}



(* -> Table of contents *)

(* {{ let _ = tableOfContents D.structure (top (List.hd !D.structure)) 1 }} *)

{{

 (*  let _ = newStruct ~in_toc:false ~numbered:false D.structure ((T "Table of contents")::[]);; *)

 (* let _ = Default.table_of_contents D.structure (top (List.hd !D.structure)) 1 ;; *)
 
 (* let _ = go_up D.structure (\* 2 *\) *)

}}
(* -< *)


=> Signatures for playgrounds

\Begin{definition}

 An \emph{individuality} category is a category $\cat{}$ equipped with a subcategory $\indiv{}$ 
     of \emph{individuals}, which is discrete.

\End{definition}

In any individuality category $\cat{}$, an \emph{interface} is an object $X$ such that the slice
category $\cat{}/X$ is empty, and a \emph{player} is a morphism $d → X$, with $d ∈ I$.

  Let us start with a category $\cat{}$. 
      

  \Begin{definition}

  A \emph{rule shape} is a diagram of the shape

\Begin{center}
    #diagram{{

        let x = rule_shape0 <<$X$.>> <<$I$>> <<$K$>> <<$J$>> <<$Y$>>

      }}

\End{center}
  in $\cat{}$, such that $I$,$J$, and $K$ are interfaces.

  \End{definition}

Letting $\rs{}$ be the base category for this diagram, we may consider the set of isomorphism classes
of rule shapes, as objects of the functor category $[\rs{},\cat{}]$. Call this set \rulescat . 
For each $ρ \in R_{ \cat{} }$, the process of adding a formal colimit to $ρ$ is implemented categorically
by taking a lax pushout of $ρ$ along the unique functor $\cat{} → 1$, as in $\cat{}[ρ]$

    \Begin{center}

    #diagram{{

      let _ = double_cell <<$\rs{}$>> <<$1$>> <<$\cat{}$>> <<$\cat{}$>> <<$a$>> <<$ρ$>> ([]) ([]) <<$x$>> ;;
	    
    }}

    \End{center}



=<


=> The $\lambda$-calculus

=<

=> References

{{ let _ = thebibliography () ;; }}

=<
