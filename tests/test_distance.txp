\Caml(
open Diagrams
open Typography.Distance
open Typography
open Document
open Document.Mathematical
open Maths
open Fonts
open Fonts.FTypes
)

\Caml(

let _ = Distance.debug := false

let get_char env c = 
    let x=Fonts.loadGlyph (Lazy.force env.mathsEnvironment.(0).mathsFont)
      ({empty_glyph with glyph_index=Fonts.glyph_of_char
	  (Lazy.force env.mathsEnvironment.(0).mathsFont) c})
    in
    List.flatten (Fonts.outlines x)

let mkEdge path profile = 
  let first = let x, y = List.hd profile in x/.100.,y/.100. in
  let profile = List.map (fun (x,y) -> 
    [x/.100.,y/.100.]) (List.tl profile) in
  path Edge.([draw;paramsOf{default_params with close=false; fillColor=None;strokingColor=Some red;}]) first profile


let profile dirs c=<<

\diagram(
let curves = get_char env c
let profile = bezier_profile dirs 3.0 curves
let _ = mkEdge path profile
) >>

let dirRight = ((-1.0,1.0),(-1.0,-1.0))
let dirLeft = ((1.0,-1.0),(1.0,1.0))
let rightProfile = profile dirRight
let leftProfile =profile dirLeft

let profiles c = << \leftProfile(c) \rightProfile(c) \hspace(0.5) >>
)

\profiles('X')  \profiles('O') \profiles('A') \profiles('C')
\profiles('P') \profiles('G') \profiles('Q') \profiles('S')

(*$X O A C P G Q S$*)


\Caml(
let bissectrice env path c1 space c2 =
  let c1 = get_char env c1 and c2 = get_char env c2 in
  let p1 = bezier_profile dirRight 3.0 c1 in
  let p2 = bezier_profile dirLeft 3.0 c2 in
  let p2 = List.map (fun (x,y) -> (x+.space,y)) p2 in

  let _ = mkEdge path p1 in
  let _ = mkEdge path p2 in
  let b = bissectrice_profile dirRight p1 p2 in
  let b = List.map (fun (l,i,r) -> i) b in
  let _ = mkEdge path b in
  ()
)

\diagram(
  let _ = bissectrice env path 'X' 600.0 'O'
)

\Caml(
let testBeta beta a = [Scope(
                    fun _ _-> Env (fun env-> { env with
		      mathsEnvironment = Array.map (fun e -> {
			e with
			  optical_beta = beta
		      }) env.mathsEnvironment;})::a
                  )])


\Caml(
let beta=0.5
)

$\testBeta(beta){A A V(a)}$ $\testBeta(0.00){A A V(a)}$

$\testBeta(beta){A × V(a)}$ $\testBeta(0.00){A × V(a)}$

$\testBeta(beta){A + V(a)}$ $\testBeta(0.00){A + V(a)}$

$\testBeta(beta){A - V(a)}$ $\testBeta(0.00){A - V(a)}$

$\testBeta(beta){A ∧ V(a)}$ $\testBeta(0.00){A ∧ V(a)}$

$\testBeta(beta){A ∨ V(a)}$ $\testBeta(0.00){A ∨ V(a)}$

$\testBeta(0.00){{β = 0.0} > {<}}$

$\testBeta(0.00){{β = 0.0} < {>}}$

$\testBeta(0.10){{β = 0.1} > {<}}$

$\testBeta(0.10){{β = 0.1} < {>}}$

$\testBeta(0.20){{β = 0.2} > {<}}$

$\testBeta(0.20){{β = 0.2} < {>}}$

$\testBeta(0.30){{β = 0.3} > {<}}$

$\testBeta(0.30){{β = 0.3} < {>}}$

$\testBeta(0.4){{β = 0.4} > {<}}$

$\testBeta(0.4){{β = 0.4} < {>}}$

$\testBeta(0.5){{β = 0.5} > {<}}$

$\testBeta(0.5){{β = 0.5} < {>}}$

$\testBeta(0.6){{β = 0.6} > {<}}$

$\testBeta(0.6){{β = 0.6} < {>}}$

$\testBeta(0.70){{β = 0.7} > {<}}$

$\testBeta(0.70){{β = 0.7} < {>}}$

$\testBeta(0.80){{β = 0.8} > {<}}$

$\testBeta(0.80){{β = 0.8} < {>}}$

$\testBeta(0.00){{β = 0.0} 〈t〉 (t)}$

$\testBeta(0.10){{β = 0.1} 〈t〉 (t)}$

$\testBeta(0.20){{β = 0.2} 〈t〉 (t)}$

$\testBeta(0.30){{β = 0.3} 〈t〉 (t)}$

$\testBeta(0.40){{β = 0.4} 〈t〉 (t)}$

$\testBeta(0.50){{β = 0.5} 〈t〉 (t)}$

$\testBeta(0.60){{β = 0.6} 〈t〉 (t)}$

$\testBeta(0.70){{β = 0.7} 〈t〉 (t)}$

$\testBeta(0.80){{β = 0.8} 〈t〉 (t)}$

$\testBeta(0.90){{β = 0.9} 〈t〉 (t)}$

