(*
  Copyright Florian Hatat, Tom Hirschowitz, Pierre Hyvernat,
  Pierre-Etienne Meunier, Christophe Raffalli, Guillaume Theyssier 2012.

  This file is part of Patoline.

  Patoline is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Patoline is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Patoline.  If not, see <http://www.gnu.org/licenses/>.
*)
\Caml(open Diagrams


)



\diagram(

      let m,ms = Matrix.(matrix [centers 10. 20.] [[
	([], <<$C$>>); 
	([], <<$C_{1}$>>); 
	([], <<$C_2$>>);
	([], <<$CD$>>)
      ];[
	([],[]) ; ([],<<A>>) ; ([], <<B>>) 
      ]])

	     let [delta;pi;sigma] = Edge.(edges [draw;arrow env (* ;dashed [2.;1.] *)] [
	       ([], ms.(0).(1), [], ms.(0).(0));
	       ([], ms.(0).(1), [], ms.(0).(2));
	       ([], ms.(0).(2), [], ms.(0).(3));
	     ])

	     let e = Edge.(edge [draw] ms.(0).(0) ~controls:[[ms.(1).(1).Node.anchor `Center];
							     [ms.(1).(2).Node.anchor `Center];[]] ms.(0).(3))

	     let _ = Node.(node [at (delta.Edge.anchor (`Curvilinear 0.1))] <<a>>)
	     let _ = Node.(node [at 
				    (Curve.eval_local 
				       e.Edge.underlying_curve 
				       (Curve.local_time e.Edge.underlying_curve 1.))] <<x>>)

	     let p = label_edgea
	     let q = label_edgea pi <<$q$>>
	     let r = label_edgea sigma <<$r$>>


)

$S'(p) = ⋀_{\{(v \xto{α} p) ∈ P_X\}} S(v)$

(* $⋀_{0 \xto{f} 1} f$ *)

\Caml(
open Diagrams

let dark_blue=RGB{red=0.;green=0.;blue=0.4}

)




\begin{center}
\diagram(
let nombre = 8
let facteur_epaisseur = 0.6
let facteur_marge = 0.6
  let sedges ?style:(style=Edge.([arrow env;draw])) = 
    List.map (fun (st,s,e) -> edge Edge.(style @ st) s e) 
  let sedges_matrix ?style:(st=Edge.([arrow env;draw])) ms l = 
    sedges ~style:st
      (List.map (fun (st',(ai,aj),(bi,bj)) -> (st',ms.(ai).(aj),ms.(bi).(bj))) l)


let m,ms = Matrix.(matrix [centers 8. 30.] 
    (let rec f n = if n = 0 then [] else
    [([],<<$C → D$>>) ; ([],<<$P$>>) ; ([],<<$S$>>); ([],<<$A$>>)] :: f (n-1) in f nombre)
)

let rec dessine taille n = 
    if n >= nombre then () 
    else 
     let _ = sedges_matrix ms [
     ([],(n,0),(n,1)) ;
     (Edge.([draw;lineWidth (facteur_epaisseur *. taille);color dark_blue]),(n,1),(n,2)) ;
    (Edge.([double (facteur_marge *. taille)]),(n,2),(n,3))
    ]
    in 
    dessine (taille +. 1.) (n + 1) 

let _ = dessine 0. 0
)
\end{center}
