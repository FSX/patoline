(*
  Copyright Florian Hatat, Tom Hirschowitz, Pierre Hyvernat,
  Pierre-Etienne Meunier, Christophe Raffalli, Guillaume Theyssier 2012.

  This file is part of Patoline.

  Patoline is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Patoline is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Patoline.  If not, see <http://www.gnu.org/licenses/>.
*)
\Caml(open Diagrams

let xrightarrows ?margin:(margin=2.) ?width:(width=1.) ?translation:(translation=(-. 3000.)) a =
  [Maths.Ordinary
       (Maths.noad
          (fun env st->
	    let module Fig = Env_Diagram (struct let env = env end) in
	    let open Entity in
	    let open Fig in

            let dr=Document.draw_boxes env (Maths.draw [{env with mathStyle = Mathematical.Script}] a) in

	    let (x0,_,x1,_) = OutputCommon.bounding_box dr in
	    let width' = max width (x1 -. x0 +. 2. *. margin) in
	    let matrix = Matrix.(make env
				 [
				   centers 0. width';
				   mainNode Node.([anchor `Pdf; at (0.,ex env);
						  innerSep 0. ; outerSep 0. ])
				 ] [[
				   (Node.([innerSep 0.;outerSep 0.;draw]), []) ; 
				   (Node.([innerSep 0.;outerSep 0.;draw]), [])
				 ]])
	    in
	    let m,ms = Matrix.(matrix.mainNode,matrix.nodes) in

	    let translation = (if translation = -. 3000. then 2. *. ex env else translation) in
	    let e = Edge.(make
			    [draw;lineWidth 0.1;arrow (* Of head *)] 
			    (Node.coord (Vector.(+) (ms.(0).(0).Node.anchor (`Main)) (0., -. 0.33 *. translation)))
			    (Node.coord (Vector.(+) (ms.(0).(1).Node.anchor (`Main)) (0.,-. 0.33 *. translation))))
	    in
	    let e' = Edge.(make
			     [draw;lineWidth 0.1;arrow (* Of head *)] 
			     (Node.coord (Vector.(+) (ms.(0).(0).Node.anchor (`Main)) (0., 0.7 *. translation)))
			     (Node.coord (Vector.(+) (ms.(0).(1).Node.anchor (`Main)) (0.,0.7 *. translation))))
	    in
	    let middle = e'.Edge.anchor (`Temporal 0.5) in
	    (* let origin = Node.(make env [circle; innerSep 0.3;fill black;anchor `Center;at (0.,0.)] []) in *)
	    let l = Node.(make_output
			    [outerSep 0.2 ; innerSep 0.; default_shape env ;
			     anchor `South; at middle] dr)
	    in
	    let drawn = 
	      drawing_inline (to_contents
		   [Node l ; Edge e ; Edge e' ; Matrix matrix])
	    in 
	    [Box.Drawing drawn] ))
  ]

)

$[0] \id(xrightarrows <$s,t$>) [1]$


\diagram(
  let m,ms = Matrix.(math_matrix [centers 20. 20.;mainNode [Node.anchor `Pdf]] 
		       [[([],<$asthsth$>) ; ([],<$AAAAA$>) ]])
  let es = edges_anchor_mid [
    (ms.(0).(0),ms.(0).(1),[],`North,[]) ;
    (Node.coord (ms.(0).(0).Node.anchor (`Angle 30.)), Node.coord (ms.(0).(1).Node.anchor (`Angle 150.)),[],`South,<<$s,t$>>) ;
    (Node.coord (ms.(0).(0).Node.anchor (`Angle 0.)), Node.coord (ms.(0).(1).Node.anchor (`Angle 180.)),[],`South,[]) ; 
    (Node.coord (ms.(0).(0).Node.anchor (`Angle (-. 30.))), Node.coord (ms.(0).(1).Node.anchor (`Angle 210.)),[],`South,[]) ; 
    (Node.coord (ms.(0).(0).Node.anchor (`Angle 45.)), Node.coord (ms.(0).(1).Node.anchor (`Angle 135.)),[],`South,[]) ; 
    (Node.coord (ms.(0).(0).Node.anchor (`Angle 90.)), Node.coord (ms.(0).(1).Node.anchor (`Angle 90.)),[Edge.bendLeft 30.],`South,[]) ; 
  ]
)
