\Caml(open Diagrams

let xrightarrows ?margin:(margin=2.) ?width:(width=1.) ?translation:(translation=(-. 3000.)) a =
  [Maths.Ordinary
       (Maths.noad
          (fun env st->
	    let module Fig = Env_Diagram (struct let env = env end) in

            let dr=Box.draw_boxes (Maths.draw [{env with mathStyle = Mathematical.Script}] a) in

	    let (x0,_,x1,_) = OutputCommon.bounding_box dr in
	    let width' = max width (x1 -. x0 +. 2. *. margin) in
	    let m,ms = Matrix.(make env
				 [
				   centers 0. width';
				   mainNode Node.([anchor `Pdf; at (0.,ex env);
						  innerSep 0. ; outerSep 0. ])
				 ] [[
				   (Node.([innerSep 0.;outerSep 0.;draw]), []) ; 
				   (Node.([innerSep 0.;outerSep 0.;draw]), [])
				 ]])
	    in

	    let translation = (if translation = -. 3000. then 2. *. ex env else translation) in
	    let e = Edge.(make
			    [draw;lineWidth 0.1;arrow (* Of head *)] 
			    (coord (Vector.(+) (ms.(0).(0).anchor (`Main)) (0., -. 0.33 *. translation)))
			    (coord (Vector.(+) (ms.(0).(1).anchor (`Main)) (0.,-. 0.33 *. translation))))
	    in
	    let e' = Edge.(make
			     [draw;lineWidth 0.1;arrow (* Of head *)] 
			     (coord (Vector.(+) (ms.(0).(0).anchor (`Main)) (0., 0.7 *. translation)))
			     (coord (Vector.(+) (ms.(0).(1).anchor (`Main)) (0.,0.7 *. translation))))
	    in
	    let middle = e'.anchor (`Temporal 0.5) in
	    (* let origin = Node.(make env [circle; innerSep 0.3;fill black;anchor `Center;at (0.,0.)] []) in *)
	    let l = Node.(make_output
			    [outerSep 0.2 ; innerSep 0.; default_shape env ;
			     anchor `South; at middle] dr)
	    in
	    let drawn = 
	      drawing_inline
		(List.fold_left (fun res gentity -> List.rev_append gentity.contents res)
		   []
		   (l :: e :: e' :: m :: (List.flatten (Array.to_list (Array.map Array.to_list ms)))))
	    in 
	    [Box.Drawing drawn] ))
  ]

)

$[0] \id(xrightarrows <$s,t$>) [1]$


\diagram(
  let m,ms = Matrix.(math_matrix [centers 20. 20.;mainNode [Node.anchor `Pdf]] 
		       [[([],<$asthsth$>) ; ([],<$AAAAA$>) ]])
  let es = edges_anchor_mid [
    (ms.(0).(0),ms.(0).(1),[],`North,[]) ;
    (coord (ms.(0).(0).anchor (`Angle 30.)), coord (ms.(0).(1).anchor (`Angle 150.)),[],`South,<<$s,t$>>) ;
    (coord (ms.(0).(0).anchor (`Angle 0.)), coord (ms.(0).(1).anchor (`Angle 180.)),[],`South,[]) ; 
    (coord (ms.(0).(0).anchor (`Angle (-. 30.))), coord (ms.(0).(1).anchor (`Angle 210.)),[],`South,[]) ; 
    (coord (ms.(0).(0).anchor (`Angle 45.)), coord (ms.(0).(1).anchor (`Angle 135.)),[],`South,[]) ; 
    (coord (ms.(0).(0).anchor (`Angle 90.)), coord (ms.(0).(1).anchor (`Angle 90.)),[Edge.bendLeft 30.],`South,[]) ; 
  ]
)
