(* #FORMAT FormatSlides *)
(* #PACKAGES mysql *)

\Caml(
open Diagrams
open Proj3d

let caml x = x

let db = Mysql.(connect { defaults with
    dbhost = Some "localhost";
    dbname = Some "patonet";
    dbpwd = Some "patonet";
    dbuser = Some "patonet";})
    
let _ = Mysql.(
    let sql = "CREATE TABLE IF NOT EXISTS `demo` (
      `key` varchar(32), `value` int);" in
    let _r = exec db sql in
    match errmsg db with
    | None -> () 
    | Some err -> Printf.eprintf "DB Error: %s\n%!" err)

let create_int name v = Mysql.(
    let sql = Printf.sprintf "INSERT INTO `demo` (`key`, `value`) VALUES ('%s',%d);" name v in
    let _r = exec db sql in
    match errmsg db with
    | None -> () 
    | Some err -> Printf.eprintf "DB Error: %s\n%!" err)

let write_int name v = Mysql.(
    let sql = Printf.sprintf "UPDATE `demo` SET `value`=%d WHERE `key` = '%s';" v name in
    let _r = exec db sql in
    match errmsg db with
    | None -> () 
    | Some err -> Printf.eprintf "DB Error: %s\n%!" err)

let rec read_int name = Mysql.(
    let sql = Printf.sprintf "SELECT `value` FROM `demo` WHERE `key` = '%s';" name in
    let r = exec db sql in
    try match errmsg db, fetch r with
    | None, Some row -> (match row.(0) with None -> 0 | Some n -> int_of_string n)
    | Some err, _ -> Printf.eprintf "DB Error: %s\n%!" err; 0
    | _ -> assert false   
    with Mysql.Error err ->
      Printf.eprintf "Mysql Error: %s\n%!" err; read_int name)

)

== Animation ==

\begin{slide}
\begin{center}
\size(5.0){Interactive Patoline}


\caml([bB (fun env-> [Drawing (image "titleduck.png" env)])])
\end{center}
\end{slide}


\begin{slide}
\begin{center}
\animation(90)(fun t -> let t = float t /. 45. *. 3.1415927 in
   let proj t = {distance_focale = 55.;
   origin_transfo_x = 10.;
   origin_transfo_y = 10.;
   origin_transfo_z = 10.; (* boucle avec 10.0 *)
   origin_diag = (10.,10.,10.); (* pour que le centre du cube ne bouge pas *)
   axe_angle = 0.;
   rot_angle = t;
   homotetie = 1.0;} in
   let projection = proj t in
<<\diagram(
(*   let _ = cube projection*)
 let a = Node.(node [anchor `Base;at3d projection (0.,0.,0.)] <<a>>) 
 let b = Node.(node [anchor `Base;at3d projection (20.,0.,0.)] <<b>>)
 let c = Node.(node [anchor `Base;at3d projection (20.,20.,0.)] <<c>>)
 let d = Node.(node [anchor `Base;at3d projection (0.,20.,0.)] <<d>>)
 let a' = Node.(node [anchor `Base;at3d projection (0.,0.,20.)] <<a'>>) 
 let b' = Node.(node [anchor `Base;at3d projection (20.,0.,20.)] <<b'>>) 
 let c' = Node.(node [anchor `Base;at3d projection (20.,20.,20.)] <<c'>>) 
 let d' = Node.(node [anchor `Base;at3d projection (0.,20.,20.)] <<d'>>) 


  let _ = edge_3d Edge.([arrow;draw]) a b
  let _ = edge_3d Edge.([arrow;draw]) d c
  let _ = edge_3d Edge.([arrow;draw]) a d
  let _ = edge_3d Edge.([arrow;draw]) b c

  let _ = edge_3d Edge.([arrow;draw]) a' b'
  let _ = edge_3d Edge.([arrow;draw]) d' c'
  let _ = edge_3d Edge.([arrow;draw]) a' d'
  let _ = edge_3d Edge.([arrow;draw]) b' c'

  let _ = edge_3d Edge.([arrow;draw]) a' a
  let _ = edge_3d Edge.([arrow;draw]) b' b
  let _ = edge_3d Edge.([arrow;draw]) c' c
  let _ = edge_3d Edge.([arrow;draw]) d' d

   let e' = Node.(node [at3d projection (10.,10.,10.);rectangle env;draw;innerSep 20.0] (<<x>>))

)>>)
\end{center}
\end{slide}

== Dynamisme ==

\begin{slide}
\begin{itemize}

\Caml(let _ = create_int "count" 0)
\item \button("test")(["cible"]){Un bouton} qui a été cliqué
\dynamic("cible")(function ev ->
  	  (match ev with 
	     Click "test"-> let c = read_int "count" + 1 in write_int "count" c; Printf.fprintf stderr "incr count to: %d\n%!" c; Public 
           | _ -> Unchanged)){0123456789 fois}(
	   fun () -> <<\caml(let c = read_int "count" in Printf.fprintf stderr "read count to: %d\n%!" c; [tT (string_of_int c)]) fois !>>)

\item Et une figure dont on peut bouger les sommets :

\begin{center}
\Caml(
let apos = ref (-10.0,-10.0)
let bpos = ref (10.0,10.0)
let cpos = ref (10.0,-10.0)
)
\dynamic("figure")(
	function ev ->
  	  (match ev with
	   | Drag("a",p) -> apos := Vector.(p + !apos); Private
	   | Drag("b",p) -> bpos := Vector.(p + !bpos); Private
	   | Drag("c",p) -> cpos := Vector.(p + !cpos); Private
	   | _ -> Unchanged))([])(fun () -> <<
\diagram(
 let frame = Node.(node [at (0.,0.);rectangle env;draw;innerSep 20.0] [])
 let av = Vector.(scal_mul 2.5 (normalise (!apos - !bpos + !apos - !cpos)))
 let bv = Vector.(scal_mul 2.5 (normalise (!bpos - !cpos + !bpos - !apos)))
 let cv = Vector.(scal_mul 2.5 (normalise (!cpos - !apos + !cpos - !bpos)))
 let ab = Node.(node [at Point.(middle !apos !bpos); innerSep 0.] [])
 let bc = Node.(node [at Point.(middle !bpos !cpos); innerSep 0.] [])
 let ca = Node.(node [at Point.(middle !cpos !apos); innerSep 0.] [])
 let a = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec av) env <<A>>; at !apos; button ("a",["figure"])] []) 
 let b = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec bv) env <<B>>; at !bpos; button ("b",["figure"])] [])
 let c = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec cv) env <<C>>; at !cpos; button ("c",["figure"])] [])
 let _ = edge Edge.([draw]) a b
 let _ = edge Edge.([draw]) b c
 let _ = edge Edge.([draw]) c a
 let _ = edge Edge.([draw]) a bc
 let _ = edge Edge.([draw]) b ca
 let _ = edge Edge.([draw]) c ab)>>)

\end{center}
\item C'est tout pour aujourd'hui !
\end{itemize}
\end{slide}
