(* #FORMAT FormatSlides *)
(* #PACKAGES mysql *)

\Caml(
open Diagrams
open Proj3d
open Typography.Db
open DefaultFormat

let caml x = x


let db_info = Mysql Mysql.(
    { defaults with
      dbhost = Some "localhost";
      dbname = Some "patonet";
      dbpwd = Some "patonet";
      dbuser = Some "patonet";})

let db = init_db "demo" db_info

let editableText ?(global=false) ?(empty_case="Type in here") ?(min_line=5)
  ?(init_text="") ?(lang=lang_default) ?(extra=fun _ -> "") name =

let name' = name^"_target" in
let name'' = name^"_target2" in

  let readT, writeT = db.create_data ~global name init_text in

let ascii = 
  let str = String.make (2*(128-32)) ' ' in
  for i = 32 to 127 do
    str.[2*(i-32)] <- Char.chr i
  done;
  [Scoped(verbEnv, [tT str] @ bold [tT str])]
in

let update () =
  let s = readT() in
  let s' = if s = "" then empty_case else s in
  s, Util.split '\n' s'
in

newPar D.structure Complete.normal ragged_left 
    (dynamic name'
	(function Edit(n, t) when name = n -> writeT t; Private 
                | _ -> Unchanged)
	ascii 	  
       (fun () ->
          let s, lines = update () in
	  let missing = max 0 (min_line - List.length lines) in
	  let lines = lines @ Array.to_list (Array.make missing "") in
          (button ~btype:(Editable s)
              name
	      [name';name'']
              [bB(fun env -> List.map (fun x-> Drawing (snd x)) (IntMap.bindings (OutputDrawing.minipage (verbEnv env)
	        (let i = ref 0 in 
		let next () =
		  incr i;
 	          let line = string_of_int !i in
	          let miss = 3 - String.length line in
	          [glue_space miss;tT line;glue_space 1]
                in
                 List.fold_left (fun acc line ->
	           let para=Paragraph {par_contents=next () @ (lang line);
                            par_env=(fun e -> e);
                            par_post_env=(fun env1 env2 -> { env1 with names=names env2; counters=env2.counters; user_positions=user_positions env2 });
                            par_parameters=ragged_left;
                            par_badness=badness;
                            par_completeLine=Complete.normal; par_states=[]; par_paragraph=(-1) }
                   in up (newChildAfter acc para)) (Node empty, []) lines))))]))) ;

newPar D.structure Complete.normal ragged_left 
    (dynamic name''
	(function Edit(n, t) when name = n -> Private 
                | _ -> Unchanged)
	ascii 	  
       (fun () ->
          let lines = Util.split '\n' (extra (readT())) in
	    [bB(fun env -> List.map (fun x-> Drawing (snd x)) (IntMap.bindings (OutputDrawing.minipage (verbEnv env)
	        (List.fold_left (fun acc line ->
	           let para=Paragraph {par_contents=(lang_default line) ;
                            par_env=(fun e -> e);
                            par_post_env=(fun env1 env2 -> { env1 with names=names env2; counters=env2.counters; user_positions=user_positions env2 });
                            par_parameters=ragged_left;
                            par_badness=badness;
                            par_completeLine=Complete.normal; par_states=[]; par_paragraph=(-1) }
                   in up (newChildAfter acc para)) (Node empty, []) lines))))]))

let test_ocaml ?(prefix="") ?(suffix="") prg =
  let tmpfile = Filename.temp_file "demo" ".ml" in
  let ch = open_out tmpfile in
  output_string ch prefix;
  output_string ch "# 1 \"\"\n";
  output_string ch prg;
  output_string ch suffix;
  close_out ch;
  let tmpfile2 = Filename.temp_file "demo" ".txt" in
  let tmpfile3 = Filename.temp_file "demo" ".txt" in
  let tmpfile4 = Filename.temp_file "demo" ".out" in
  let _ = Sys.command (Printf.sprintf "ocamlc.opt -o %s %s 2>%s >%s" tmpfile4 tmpfile tmpfile3 tmpfile2) in
  let err =
    let ch = open_in tmpfile3 in
    let len = in_channel_length ch in
    let str = String.create len in
    let _ = input ch str 0 len in
    str
  in
  if err <> "" then err else (
    ignore (Sys.command (Printf.sprintf "%s 2>%s >%s" tmpfile4 tmpfile3 tmpfile2));
  let err =
    let ch = open_in tmpfile3 in
    let len = in_channel_length ch in
    let str = String.create len in
    let _ = input ch str 0 len in
    str
  in  
  let out =
    let ch = open_in tmpfile2 in
    let len = in_channel_length ch in
    let str = String.create len in
    let _ = input ch str 0 len in
    str
  in  
  if err <> "" then err else 
  if out <> "" then out else "No error and no output")
  
)


== Animation ==

\begin{slide}
\begin{center}
\size(5.0){Interactive Patoline}


\caml([bB (fun env-> [Drawing (image "titleduck.png" env)])])
\end{center}
\end{slide}


\begin{slide}
\begin{center}
\animation(90)(fun t -> let t = float t /. 45. *. 3.1415927 in
   let proj t = {distance_focale = 55.;
   origin_transfo_x = 10.;
   origin_transfo_y = 10.;
   origin_transfo_z = 10.; (* boucle avec 10.0 *)
   origin_diag = (10.,10.,10.); (* pour que le centre du cube ne bouge pas *)
   axe_angle = 0.;
   rot_angle = t;
   homotetie = 1.0;} in
   let projection = proj t in
<<\diagram(
(*   let _ = cube projection*)
 let a = Node.(node [anchor `Base;at3d projection (0.,0.,0.)] <<a>>) 
 let b = Node.(node [anchor `Base;at3d projection (20.,0.,0.)] <<b>>)
 let c = Node.(node [anchor `Base;at3d projection (20.,20.,0.)] <<c>>)
 let d = Node.(node [anchor `Base;at3d projection (0.,20.,0.)] <<d>>)
 let a' = Node.(node [anchor `Base;at3d projection (0.,0.,20.)] <<a'>>) 
 let b' = Node.(node [anchor `Base;at3d projection (20.,0.,20.)] <<b'>>) 
 let c' = Node.(node [anchor `Base;at3d projection (20.,20.,20.)] <<c'>>) 
 let d' = Node.(node [anchor `Base;at3d projection (0.,20.,20.)] <<d'>>) 


  let _ = edge_3d Edge.([arrow;draw]) a b
  let _ = edge_3d Edge.([arrow;draw]) d c
  let _ = edge_3d Edge.([arrow;draw]) a d
  let _ = edge_3d Edge.([arrow;draw]) b c

  let _ = edge_3d Edge.([arrow;draw]) a' b'
  let _ = edge_3d Edge.([arrow;draw]) d' c'
  let _ = edge_3d Edge.([arrow;draw]) a' d'
  let _ = edge_3d Edge.([arrow;draw]) b' c'

  let _ = edge_3d Edge.([arrow;draw]) a' a
  let _ = edge_3d Edge.([arrow;draw]) b' b
  let _ = edge_3d Edge.([arrow;draw]) c' c
  let _ = edge_3d Edge.([arrow;draw]) d' d

   let e' = Node.(node [at3d projection (10.,10.,10.);rectangle env;draw;innerSep 20.0] (<<x>>))

)>>)
\end{center}
\end{slide}

== Dynamisme ==

\begin{slide}
\begin{itemize}

\Caml(let read_count, write_count = db.create_data ~global:true "count" 0)
\item \button("test")(["cible"]){Un bouton} qui a été cliqué
\dynamic("cible")(function ev ->
  	  (match ev with 
	     Click "test"-> let c = read_count () + 1 in write_count c; Public 
           | _ -> Unchanged)){0123456789 fois}(
	   fun () -> <<\caml(let c = read_count () in [tT (string_of_int c)]) fois !>>)

\Caml(let read_count2, write_count2 = db.create_data ~global:false "count" 0)
\item \button("test")(["cible2"]){Un autre bouton} qui a été cliqué
\dynamic("cible2")(function ev ->
  	  (match ev with 
	     Click "test"-> let c = read_count2 () + 1 in write_count2 c; Public 
           | _ -> Unchanged)){0123456789 fois}(
	   fun () -> <<\caml(let c = read_count2 () in [tT (string_of_int c)]) fois !>>)

\item Chercher la différence entre ces deux boutons ! indication~: ouvrez deux fois la présentation.

\item Et une figure dont on peut bouger les sommets :

\begin{center}
\Caml(
let readA, writeA = db.create_data ~global:false "Apos" (10.0,10.0)
let readB, writeB = db.create_data ~global:false "Bpos" (-10.0,-10.0)
let readC, writeC = db.create_data ~global:false "Cpos" (10.0,-10.0)
)
\dynamic("figure")(
	function ev ->
  	  (match ev with
	   | Drag("a",p) -> writeA Vector.(p + readA ()); Private
	   | Drag("b",p) -> writeB Vector.(p + readB ()); Private
	   | Drag("c",p) -> writeC Vector.(p + readC ()); Private
	   | _ -> Unchanged))([])(fun () -> <<
\diagram(
 let frame = Node.(node [at (0.,0.);rectangle env;draw; color (mix 0.5 white blue); innerSep 20.] [])
 let apos = readA () and bpos = readB () and cpos = readC ()
 let av = Vector.(scal_mul 3. (normalise (apos - bpos + apos - cpos)))
 let bv = Vector.(scal_mul 3. (normalise (bpos - cpos + bpos - apos)))
 let cv = Vector.(scal_mul 3. (normalise (cpos - apos + cpos - bpos)))
 let ab = Node.(node [at Point.(middle apos bpos); innerSep 0.] [])
 let bc = Node.(node [at Point.(middle bpos cpos); innerSep 0.] [])
 let ca = Node.(node [at Point.(middle cpos apos); innerSep 0.] [])
 let a = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec av) env <<A>>; at apos; drag ("a",["figure"])] []) 
 let b = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec bv) env <<B>>; at bpos; drag ("b",["figure"])] [])
 let c = Node.(node [circle; fill black; innerSep 0.4; label ~pos:(`Vec cv) env <<C>>; at cpos; drag ("c",["figure"])] [])
 let _ = edge Edge.([draw]) a b
 let _ = edge Edge.([draw]) b c
 let _ = edge Edge.([draw]) c a
 let _ = edge Edge.([draw]) a bc
 let _ = edge Edge.([draw]) b ca
 let _ = edge Edge.([draw]) c ab
)>>)

\end{center}
\end{itemize}
\end{slide}

\Caml(
type sondage =
  Null
| Fun_but
| Fun_yes
| No_opinion
| No_answer

let readSonde, writeSonde = db.create_data ~global:false "sondage" No_answer

let box name s =
 dynamic name
 (function ev -> Private) 
 (<<$X$ $O$>>)
 (fun () -> if readSonde () = s then (<<$X$>>) else (<<$O$>>))
)

\begin{slide}

\begin{center}
\size(5.0){Un petit sondage}
\vspaceAfter(5.0)
\end{center}

\button("Null")(["Sondage";"Null";"Fun_but";"Fun_yes";"No_opinion"]){
  \box("Null")(Null) Patoline c'est null, ça ne marchera jamais.}

\button("Fun_but")(["Sondage";"Null";"Fun_but";"Fun_yes";"No_opinion"]){
  \box("Fun_but")(Fun_but) Patoline c'est chouette, mais ça ne marchera pas.}

\button("Fun_yes")(["Sondage";"Null";"Fun_but";"Fun_yes";"No_opinion"]){
  \box("Fun_yes")(Fun_yes) Patoline c'est chouette, et ça va casser la baraque !}

\button("No_opinion")(["Sondage";"Null";"Fun_but";"Fun_yes";"No_opinion"]){
  \box("No_opinion")(No_opinion) Je ne sais pas.}
\end{slide}

\begin{slide}
\begin{center}
\size(5.0){Résultats du sondage}
\end{center}

\begin{dynamic}("Sondage")(
 function
   Click("Null") -> writeSonde Null; Public
 | Click("Fun_but") -> writeSonde Fun_but; Public
 | Click("Fun_yes") -> writeSonde Fun_yes; Public
 | Click("No_opinion") -> writeSonde No_opinion; Public
 | _ -> Unchanged)([])

\Caml(
let result = ref []
let update () = 
 let mysql_db = match db.db () with
  MysqlDb db -> db(* | _ -> assert false*) in
let sql = "SELECT `value`,COUNT(`sessid`) FROM `demo` WHERE `key` = 'sondage' GROUP BY `value`" in
let r = Mysql.exec mysql_db sql in
let f = function None -> "" | Some s -> s in
result :=  
  let l = ref [] in
  try while true do
    match Mysql.fetch r with 
      None -> raise Exit
    | Some row -> l := (Marshal.from_string (base64_decode (f row.(0))) 0, f row.(1))::!l
  done; []
  with Exit -> !l
)

\begin{itemize}
\item Null~: \caml([C (fun env -> update (); let n = try List.assoc Null !result with Not_found -> "0" in [tT n])])

\item Fun but~: \caml([C (fun env -> let n = try List.assoc Fun_but !result with Not_found -> "0" in [tT n])])

\item Fun yes~: \caml([C (fun env -> let n = try List.assoc Fun_yes !result with Not_found -> "0" in [tT n])])

\item No opinion~: \caml([C (fun env -> let n = try List.assoc No_opinion !result with Not_found -> "0" in [tT n])])
\end{itemize}
\end{dynamic}
\end{slide}

\begin{slide}

Un petit programme éditable~:


\Caml(
let _ = editableText ~min_line:13 ~lang:lang_OCaml ~extra:(fun s -> test_ocaml s) "testText" 
)

\end{slide}
